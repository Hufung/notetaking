<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PDF Editor (Zoom & Pen Fix)</title>
    
    <style>
        /* General Setup */
        :root {
            --bg-dark: #2c2f33; --bg-medium: #40444b; --bg-light: #525659;
            --text-light: #ffffff; --text-medium: #b9bbbe; --accent: #7289da;
        }
        html, body {
            margin: 0; padding: 0; height: 100%; width: 100%;
            overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-light); color: var(--text-light);
        }

        /* App Layout */
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        .main-content { flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; position: relative; }

        /* Toolbar */
        .toolbar {
            flex-shrink: 0; background-color: var(--bg-dark); padding: 8px 16px;
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 16px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 1000;
        }
        .tool-group { display: flex; align-items: center; gap: 8px; border-left: 1px solid var(--bg-light); padding-left: 16px; }
        .tool-btn {
            background: none; border: 2px solid transparent; border-radius: 8px; padding: 8px; 
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .tool-btn svg { width: 24px; height: 24px; stroke: var(--text-medium); transition: stroke 0.2s; }
        .tool-btn:hover { background-color: var(--bg-medium); }
        .tool-btn.active { background-color: var(--bg-medium); border-color: var(--accent); }
        .tool-btn.active svg { stroke: var(--accent); }
        .tool-btn:disabled { cursor: not-allowed; opacity: 0.5; }

        /* Tool Properties Bar */
        #tool-properties { display: flex; align-items: center; gap: 12px; }
        input[type="color"] { border: none; background: none; width: 32px; height: 32px; cursor: pointer; border-radius: 50%; overflow: hidden; }
        input[type="range"] { cursor: pointer; }
        #stroke-width-label { min-width: 20px; text-align: center; }

        /* PDF Viewer & Centering */
        #pdf-wrapper { position: relative; }
        #pdf-viewer-container {
            position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            touch-action: none;
            /* --- KEY FIX for predictable zooming --- */
            transform-origin: top left;
        }
        #pdf-viewer-container[data-tool="pan"] { cursor: grab; }
        #pdf-viewer-container[data-tool="pan"].panning { cursor: grabbing; }
        #pdf-canvas, #annotation-canvas { position: absolute; top: 0; left: 0; }
        
        /* On-Screen Page Navigation & Modals */
        .page-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 50px; height: 100px; background: rgba(0,0,0,0.2); border-radius: 10px; 
            display: flex; justify-content: center; align-items: center; cursor: pointer; 
            z-index: 500; opacity: 0; transition: opacity 0.3s;
        }
        .main-content:hover .page-nav { opacity: 0.7; }
        #prev-page-overlay { left: 20px; }
        #next-page-overlay { right: 20px; }
        .page-nav.disabled { display: none; }
        .modal-overlay, #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            display: none; justify-content: center; align-items: center; z-index: 9998;
        }
        .modal {
            background: var(--bg-dark); padding: 24px; border-radius: 8px; box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto;
        }
        #file-list { list-style: none; padding: 0; }
        .spinner { width: 50px; height: 50px; border: 5px solid var(--bg-light); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
             <div class="tool-group">
                <button class="tool-btn" id="files-btn" title="Open Local Files">...</button>
                <button class="tool-btn" id="upload-btn" title="Import New PDF">...</button>
                <button class="tool-btn" id="save-btn" disabled title="Save to Browser">...</button>
            </div>
            <span id="page-num-display">No PDF Loaded</span>
            <div class="tool-group">
                <button class="tool-btn" id="undo-btn" disabled title="Undo (Ctrl+Z)">...</button>
                <button class="tool-btn" id="redo-btn" disabled title="Redo (Ctrl+Y)">...</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" data-tool="pan" title="Move View (M)">...</button>
                <button class="tool-btn" data-tool="draw" title="Pen (P)">...</button>
                <button class="tool-btn" data-tool="highlight" title="Highlighter (H)">...</button>
                <button class="tool-btn" data-tool="eraser" title="Eraser (E)">...</button>
            </div>
            <div id="tool-properties" class="tool-group"></div>
             <div class="tool-group">
                <button class="tool-btn" id="reset-view-btn" title="Fit to Screen (F)">...</button>
                <button class="tool-btn" id="download-btn" disabled title="Download a Copy">...</button>
            </div>
        </div>
        
        <div class="main-content" id="main-content">
            <div id="pdf-wrapper"><div id="pdf-viewer-container"><canvas id="pdf-canvas"></canvas><canvas id="annotation-canvas"></canvas></div></div>
            <div id="prev-page-overlay" class="page-nav disabled">...</div>
            <div id="next-page-overlay" class="page-nav disabled">...</div>
        </div>
    </div>
    <div id="files-modal" class="modal-overlay">...</div>
    <div id="loading-overlay"><div class="spinner"></div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script>
    // --- SETUP & DOM ELEMENTS (ABBREVIATED FOR CLARITY, FULL HTML IS ABOVE) ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;
    const getEl = id => document.getElementById(id); const viewerContainer = getEl('main-content'), pdfWrapper = getEl('pdf-wrapper'), pdfContainer = getEl('pdf-viewer-container');
    const pdfCanvas = getEl('pdf-canvas'), annotationCanvas = getEl('annotation-canvas'); const pdfCtx = pdfCanvas.getContext('2d'), annotationCtx = annotationCanvas.getContext('2d');
    
    // --- STATE MANAGEMENT ---
    let pdfDoc = null, pageNum = 1, currentFileId = null; let annotations = {}; let history = {}, redoStack = {};
    const state = {
        transform: { scale: 1, offsetX: 0, offsetY: 0 }, isDrawing: false, currentPath: null, activeTool: 'pan',
        toolSettings: { draw: { color: '#ff0000', width: 3 }, highlight: { color: '#ffff00', width: 20 }, eraser: { width: 20 } }
    };
    const pointerCache = new Map(); let prevPinchDist = null;
    const ZOOM_SENSITIVITY = 1.1, MIN_ZOOM = 0.1, MAX_ZOOM = 10;

    // --- DATABASE (INDEXEDDB) - UNCHANGED ---
    let db; function openDB() { /* ... */ }

    // --- RENDERING ENGINE ---
    function render() {
        if (!pdfDoc) return;
        getEl('loading-overlay').style.display = 'flex';
        pdfDoc.getPage(pageNum).then(page => {
            const pdfViewport = page.getViewport({ scale: 1 });
            pdfContainer.style.width = `${pdfViewport.width}px`; pdfContainer.style.height = `${pdfViewport.height}px`;
            pdfCanvas.width = pdfViewport.width; pdfCanvas.height = pdfViewport.height;
            annotationCanvas.width = pdfViewport.width; annotationCanvas.height = pdfViewport.height;
            
            pdfContainer.style.transform = `translate(${state.transform.offsetX}px, ${state.transform.offsetY}px) scale(${state.transform.scale})`;
            
            page.render({ canvasContext: pdfCtx, viewport: pdfViewport }).promise.then(() => {
                redrawAnnotations();
                getEl('loading-overlay').style.display = 'none';
            });
        });
        getEl('page-num-display').textContent = `Page ${pageNum} / ${pdfDoc.numPages}`;
        getEl('prev-page-overlay').classList.toggle('disabled', pageNum <= 1);
        getEl('next-page-overlay').classList.toggle('disabled', pageNum >= pdfDoc.numPages);
    }
    
    function redrawAnnotations() { /* ... UNCHANGED ... */ }
    function fitToScreen() { /* ... UNCHANGED ... */ }
    
    // --- UNDO/REDO & HISTORY - UNCHANGED ---
    function recordHistory() { /* ... */ }
    function undo() { /* ... */ }
    function redo() { /* ... */ }
    function updateUndoRedoButtons() { /* ... */ }

    // --- FILE MANAGEMENT & UI - UNCHANGED ---
    async function loadFile(id, fileData, annotationData) { /* ... */ }
    function setActiveTool(tool) { /* ... */ }
    function updateToolPropertiesUI() { /* ... */ }
    
    // --- CORE EVENT LOGIC (WITH BUG FIXES) ---

    /**
     * KEY FIX: Translates screen coordinates (e.g., from a mouse click or pen tap)
     * into the internal, unscaled coordinates of the canvas. This accounts for
     * the current pan and zoom level.
     */
    function getTransformedCoords(clientX, clientY) {
        const wrapperRect = pdfWrapper.getBoundingClientRect();
        const x = (clientX - wrapperRect.left - state.transform.offsetX) / state.transform.scale;
        const y = (clientY - wrapperRect.top - state.transform.offsetY) / state.transform.scale;
        return { x, y };
    }

    viewerContainer.addEventListener('wheel', e => {
        e.preventDefault();
        const oldScale = state.transform.scale;
        let newScale = e.deltaY < 0 ? oldScale * ZOOM_SENSITIVITY : oldScale / ZOOM_SENSITIVITY;
        newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newScale)); // Clamp zoom

        // --- KEY FIX: Zoom towards the cursor position ---
        const wrapperRect = pdfWrapper.getBoundingClientRect();
        const clientX = e.clientX - wrapperRect.left;
        const clientY = e.clientY - wrapperRect.top;

        // Adjust offset to keep the point under the cursor stationary
        state.transform.offsetX = clientX - (clientX - state.transform.offsetX) * (newScale / oldScale);
        state.transform.offsetY = clientY - (clientY - state.transform.offsetY) * (newScale / oldScale);
        state.transform.scale = newScale;
        
        render();
    });
        
    viewerContainer.addEventListener('pointerdown', e => {
        if (!pdfDoc) return;
        pointerCache.set(e.pointerId, { lastX: e.clientX, lastY: e.clientY });
        
        const isDrawingTool = state.activeTool === 'draw' || state.activeTool === 'highlight';
        const isEraserTool = state.activeTool === 'eraser';
        
        if ((isDrawingTool && e.pointerType === 'pen') || (isEraserTool && e.pointerType !== 'touch')) {
            recordHistory();
            state.isDrawing = true;
            const { x, y } = getTransformedCoords(e.clientX, e.clientY);
            
            if (isDrawingTool) {
                const settings = state.toolSettings[state.activeTool];
                state.currentPath = { type: state.activeTool, points: [{ x, y }], color: settings.color, width: settings.width };
                if (!annotations[pageNum]) annotations[pageNum] = [];
                annotations[pageNum].push(state.currentPath);
            } else { // Eraser
                eraseAtPoint({ x, y });
            }
        }
    });

    viewerContainer.addEventListener('pointermove', e => {
        if (!pointerCache.has(e.pointerId)) return;
        const currentPointer = pointerCache.get(e.pointerId);

        if (state.isDrawing) {
            const { x, y } = getTransformedCoords(e.clientX, e.clientY);
            if (state.activeTool === 'draw' || state.activeTool === 'highlight') {
                state.currentPath.points.push({ x, y });
                redrawAnnotations();
            } else if (state.activeTool === 'eraser') {
                eraseAtPoint({ x, y });
            }
        } else if (pointerCache.size === 1 && state.activeTool === 'pan') {
            pdfContainer.classList.add('panning');
            const dx = e.clientX - currentPointer.lastX;
            const dy = e.clientY - currentPointer.lastY;
            state.transform.offsetX += dx;
            state.transform.offsetY += dy;
            render();
        } else if (pointerCache.size === 2) {
            const pointers = Array.from(pointerCache.values());
            pointers[0] = { lastX: e.clientX, lastY: e.clientY }; // Update the moving pointer
            const dist = Math.hypot(pointers[0].lastX - pointers[1].lastX, pointers[0].lastY - pointers[1].lastY);

            if (prevPinchDist) {
                const oldScale = state.transform.scale;
                let newScale = oldScale * (dist / prevPinchDist);
                newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newScale)); // Clamp zoom
                
                // --- KEY FIX: Zoom towards pinch center ---
                const midX = (pointers[0].lastX + pointers[1].lastX) / 2;
                const midY = (pointers[0].lastY + pointers[1].lastY) / 2;
                const wrapperRect = pdfWrapper.getBoundingClientRect();
                const clientX = midX - wrapperRect.left;
                const clientY = midY - wrapperRect.top;

                state.transform.offsetX = clientX - (clientX - state.transform.offsetX) * (newScale / oldScale);
                state.transform.offsetY = clientY - (clientY - state.transform.offsetY) * (newScale / oldScale);
                state.transform.scale = newScale;
                render();
            }
            prevPinchDist = dist;
        }
        
        currentPointer.lastX = e.clientX;
        currentPointer.lastY = e.clientY;
    });

    function handlePointerUp(e) {
        pointerCache.delete(e.pointerId);
        if (pointerCache.size < 2) prevPinchDist = null;
        if (pointerCache.size < 1) pdfContainer.classList.remove('panning');
        if (state.isDrawing) {
            state.isDrawing = false;
            state.currentPath = null;
            updateUndoRedoButtons();
        }
    }
    viewerContainer.addEventListener('pointerup', handlePointerUp);
    viewerContainer.addEventListener('pointercancel', handlePointerUp);

    // --- INITIALIZATION ---
    async function init() {
        // Fill in abbreviated HTML content
        document.querySelectorAll('.tool-btn svg, .page-nav svg').forEach(el => el.parentElement.innerHTML = el.parentElement.title);
        await openDB();
        setActiveTool('pan');
        window.addEventListener('resize', fitToScreen);
    }
    init();
    
    // --- All other functions (DB, UI, Download, etc.) are included but unchanged from the previous version ---
    // This is a placeholder for the full, unchanged functions from the prior step.
    // They are necessary for the app to work but omitted here to highlight the bug fixes.
    const unchangedFunctions = () => {
        function openDB(){/*...*/} function redrawAnnotations(){/*...*/} function fitToScreen(){/*...*/}
        function recordHistory(){/*...*/} function undo(){/*...*/} function redo(){/*...*/} function updateUndoRedoButtons(){/*...*/}
        async function loadFile(){/*...*/} function setActiveTool(){/*...*/} function updateToolPropertiesUI(){/*...*/}
        function eraseAtPoint(){/*...*/} window.addEventListener('keydown', ()=>{/*...*/}); 
        getEl('download-btn').addEventListener('click', async ()=>{/*...*/});
    };
    </script>
</body>
</html>
