<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PDF Editor Pro</title>
    
    <style>
        /* --- THEME & RESET --- */
        :root {
            --bg-dark: #202225; --bg-medium: #2f3136; --bg-light: #36393f;
            --text-light: #ffffff; --text-muted: #a0a0a0; --accent: #5865f2;
        }
        html, body {
            margin: 0; padding: 0; height: 100%; width: 100%;
            overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-light); color: var(--text-light);
            touch-action: none; 
        }

        .app-container { display: flex; flex-direction: column; height: 100vh; position: relative; }

        /* --- TOOLBAR --- */
        .toolbar {
            flex-shrink: 0; background-color: var(--bg-dark); padding: 8px 16px;
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 2000;
        }
        .toolbar-section { display: flex; align-items: center; gap: 10px; }
        
        /* Buttons */
        .tool-btn {
            background: var(--bg-medium); border: 1px solid transparent; border-radius: 6px; padding: 8px 12px; 
            cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;
            color: var(--text-light); font-size: 14px; transition: all 0.2s; text-decoration: none;
        }
        .tool-btn svg { width: 18px; height: 18px; stroke-width: 2; stroke: currentColor; }
        .tool-btn:hover { background-color: #40444b; }
        .tool-btn.active { background-color: var(--accent); border-color: var(--accent); color: white; }
        
        #tool-properties { display: flex; align-items: center; gap: 10px; padding-left: 10px; border-left: 1px solid #444; }
        input[type="color"] { border: none; width: 24px; height: 24px; padding: 0; background: none; cursor: pointer; }
        input[type="range"] { width: 80px; cursor: pointer; }
        
        .zoom-indicator {
            font-size: 13px; font-weight: bold; color: var(--accent); min-width: 45px; text-align: right;
        }

        /* --- MAIN VIEWPORT --- */
        .main-content { 
            flex-grow: 1; position: relative; background: var(--bg-light); 
            overflow: hidden; touch-action: none; 
            display: flex; justify-content: center; align-items: center;
        }

        #pdf-viewer-container {
            position: absolute; 
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            transform-origin: 0 0; 
            will-change: transform;
        }
        #pdf-viewer-container[data-tool="pan"] { cursor: grab; }
        #pdf-viewer-container[data-tool="pan"].panning { cursor: grabbing; }
        #pdf-viewer-container[data-tool="link"] { cursor: crosshair; }
        
        /* Canvas Layers */
        #pdf-canvas, #annotation-canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        /* Page Nav */
        .page-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 50px; height: 100px; background: rgba(0,0,0,0.2);
            border-radius: 8px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 500; opacity: 0; transition: opacity 0.2s; user-select: none;
        }
        .main-content:hover .page-nav { opacity: 1; }
        .page-nav:hover { background: rgba(0,0,0,0.5); }
        #prev-page-overlay { left: 10px; }
        #next-page-overlay { right: 10px; }
        .page-nav.disabled { display: none; }

        /* Loading */
        #loading-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.6); display: none; 
            justify-content: center; align-items: center; z-index: 9999; 
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #fff; border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- TOOLBAR -->
        <div class="toolbar">
            <div class="toolbar-section">
                <!-- LINK TO FILES PAGE -->
                <a href="files.html" class="tool-btn" title="Go to File Library">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
                    Files
                </a>
                
                <input type="file" id="pdf-upload" accept="application/pdf" style="display: none;">
                <button class="tool-btn" id="upload-btn" title="New PDF"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg> New</button>
                <button class="tool-btn" id="save-btn" disabled title="Save to Library"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg> Save</button>
                <button class="tool-btn" id="download-btn" disabled title="Export File"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg></button>
            </div>

            <div class="toolbar-section">
                <span id="page-num-display" style="color: var(--text-muted); font-size: 13px;">No File</span>
                <button class="tool-btn" id="undo-btn" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg></button>
                <button class="tool-btn" id="redo-btn" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path></svg></button>
            </div>

            <div class="toolbar-section">
                <button class="tool-btn" data-tool="pan" title="Pan / Click Links"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></button>
                <button class="tool-btn" data-tool="draw" title="Pen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle></svg></button>
                <button class="tool-btn" data-tool="line" title="Straight Line"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="4" y1="20" x2="20" y2="4"></line></svg></button>
                <button class="tool-btn" data-tool="highlight" title="Marker"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg></button>
                <button class="tool-btn" data-tool="link" title="Insert Link URL"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></button>
                <button class="tool-btn" data-tool="eraser" title="Eraser"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                
                <div id="tool-properties"></div>
                <button class="tool-btn" id="reset-view-btn" title="Fit View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path></svg></button>
                <span id="zoom-indicator" class="zoom-indicator">100%</span>
            </div>
        </div>
        
        <!-- VIEWER -->
        <div class="main-content" id="main-content">
            <div id="pdf-viewer-container">
                <canvas id="pdf-canvas"></canvas>
                <canvas id="annotation-canvas"></canvas>
            </div>
            <div id="prev-page-overlay" class="page-nav disabled">â€¹</div>
            <div id="next-page-overlay" class="page-nav disabled">â€º</div>
        </div>
    </div>
    
    <div id="loading-overlay"><div class="spinner"></div></div>

    <!-- SCRIPTS -->
    <script src="https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script>
    // --- INIT ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js`;
    
    const getEl = id => document.getElementById(id);
    const mainContent = getEl('main-content');
    const pdfCanvas = getEl('pdf-canvas'), annotationCanvas = getEl('annotation-canvas');
    const pdfCtx = pdfCanvas.getContext('2d'), annotationCtx = annotationCanvas.getContext('2d');
    const pdfContainer = getEl('pdf-viewer-container');
    const zoomIndicator = getEl('zoom-indicator');
    
    // Buttons
    const uploadBtn = getEl('upload-btn'), uploadInput = getEl('pdf-upload');
    const saveBtn = getEl('save-btn'), downloadBtn = getEl('download-btn');
    const undoBtn = getEl('undo-btn'), redoBtn = getEl('redo-btn');
    
    // State
    let pdfDoc = null, originalPdfBytes = null, pageNum = 1, currentFileId = null;
    let annotations = {};
    let history = {}, redoStack = {};
    let isDbReady = false;
    let db;
    
    const state = {
        transform: { scale: 1, offsetX: 0, offsetY: 0 },
        isDrawing: false, currentPath: null, activeTool: 'pan',
        toolSettings: { draw: { color: '#ff0000', width: 3 }, line: { color: '#ff0000', width: 3 }, highlight: { color: '#ffff00', width: 20 }, eraser: { width: 20 }, link: { color: '#5865f2' } }
    };
    const pointerCache = new Map();
    let prevPinchDist = null;

    // --- DB Setup ---
    function openDB() {
        return new Promise((resolve) => {
            const req = indexedDB.open('PDFEditorProDB', 1);
            req.onerror = () => { console.warn("DB Blocked"); resolve(null); };
            req.onsuccess = () => { db = req.result; isDbReady = true; resolve(db); };
            req.onupgradeneeded = e => {
                const db = e.target.result;
                if(!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('annotations')) db.createObjectStore('annotations', { keyPath: 'fileId' });
            };
        });
    }

    // --- LOAD FROM DB ---
    async function checkURLForFile() {
        const urlParams = new URLSearchParams(window.location.search);
        const fileId = urlParams.get('id');
        
        if (fileId && isDbReady) {
            getEl('loading-overlay').style.display = 'flex';
            try {
                const tx = db.transaction(['files', 'annotations'], 'readonly');
                const f = await tx.objectStore('files').get(parseInt(fileId));
                const a = await tx.objectStore('annotations').get(parseInt(fileId));
                
                if (f) {
                    await loadFile(f.id, f.data, a ? a.data : {}, f.name);
                } else {
                    alert("File not found");
                }
            } catch (e) { console.error(e); }
            getEl('loading-overlay').style.display = 'none';
        }
    }

    // --- PDF LOGIC ---
    function render() {
        if (!pdfDoc) return;
        pdfDoc.getPage(pageNum).then(page => {
            const scaleFactor = 1.5; 
            const viewport = page.getViewport({ scale: scaleFactor });
            pdfContainer.style.width = `${viewport.width}px`; pdfContainer.style.height = `${viewport.height}px`;
            pdfCanvas.width = viewport.width; pdfCanvas.height = viewport.height;
            annotationCanvas.width = viewport.width; annotationCanvas.height = viewport.height;
            pdfContainer.style.transform = `translate(${state.transform.offsetX}px, ${state.transform.offsetY}px) scale(${state.transform.scale})`;
            zoomIndicator.textContent = Math.round(state.transform.scale * 100) + '%';
            page.render({ canvasContext: pdfCtx, viewport: viewport }).promise.then(() => redrawAnnotations());
        });
        getEl('page-num-display').textContent = `Page ${pageNum}`;
        updatePageNavButtons();
    }
    
    function redrawAnnotations() {
        annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        const listToDraw = [...(annotations[pageNum] || [])];
        if (state.isDrawing && state.currentPath && (state.activeTool === 'line' || state.activeTool === 'link')) {
            listToDraw.push(state.currentPath);
        }

        listToDraw.forEach(anno => {
            annotationCtx.save();
            if (anno.type === 'link') {
                annotationCtx.fillStyle = 'rgba(88, 101, 242, 0.2)'; annotationCtx.strokeStyle = 'rgba(88, 101, 242, 0.8)';
                annotationCtx.lineWidth = 2; annotationCtx.fillRect(anno.x, anno.y, anno.w, anno.h); annotationCtx.strokeRect(anno.x, anno.y, anno.w, anno.h);
                annotationCtx.fillStyle = '#fff'; annotationCtx.font = '12px sans-serif'; annotationCtx.fillText("ðŸ”—", anno.x + 4, anno.y + 16);
            } else {
                annotationCtx.beginPath(); annotationCtx.moveTo(anno.points[0].x, anno.points[0].y);
                if (anno.type === 'line') { const end = anno.points[1] || anno.points[0]; annotationCtx.lineTo(end.x, end.y); } 
                else { anno.points.forEach(p => annotationCtx.lineTo(p.x, p.y)); }
                if (anno.type === 'highlight') annotationCtx.globalAlpha = 0.4;
                annotationCtx.strokeStyle = anno.color; annotationCtx.lineWidth = anno.width; annotationCtx.lineCap = 'round'; annotationCtx.lineJoin = 'round'; annotationCtx.stroke(); 
            }
            annotationCtx.restore();
        });
    }
    
    function fitToScreen() {
        if (!pdfDoc) return;
        pdfDoc.getPage(pageNum).then(page => {
            const viewport = page.getViewport({ scale: 1.5 });
            const rect = mainContent.getBoundingClientRect();
            const scale = Math.min((rect.width / viewport.width) * 0.95, (rect.height / viewport.height) * 0.95);
            state.transform = { scale, offsetX: (rect.width - (viewport.width * scale)) / 2, offsetY: (rect.height - (viewport.height * scale)) / 2 };
            render();
        });
    }

    async function loadFile(id, fileData, annotationData, name) {
        currentFileId = id; originalPdfBytes = fileData; annotations = annotationData || {}; history = {}; redoStack = {};
        pdfDoc = await pdfjsLib.getDocument(new Uint8Array(originalPdfBytes)).promise;
        pageNum = 1; document.title = name || "PDF Editor";
        fitToScreen();
        [saveBtn, downloadBtn, undoBtn, redoBtn].forEach(b => b.disabled = false);
        updateUndoRedoButtons();
    }

    // --- ACTIONS ---
    uploadBtn.onclick = () => uploadInput.click();
    uploadInput.onchange = async e => {
        const file = e.target.files[0]; if (!file) return;
        const buffer = await file.arrayBuffer();
        // Reset URL when uploading new file
        window.history.pushState({}, document.title, window.location.pathname);
        await loadFile(null, buffer, {}, file.name);
    };

    saveBtn.onclick = async () => {
        if (!pdfDoc || !isDbReady) return;
        let fileId = currentFileId;
        let fileName = document.title;
        if (!fileId) {
            fileName = prompt("File Name:", fileName.replace('*', ''));
            if (!fileName) return;
            fileId = Date.now();
        }
        getEl('loading-overlay').style.display = 'flex';
        // Thumbnail
        const thumbCvs = document.createElement('canvas'); const thumbSize = 120;
        const ratio = pdfCanvas.width / pdfCanvas.height; thumbCvs.width = thumbSize; thumbCvs.height = thumbSize / ratio;
        const tCtx = thumbCvs.getContext('2d'); tCtx.fillStyle = '#fff'; tCtx.fillRect(0,0,thumbCvs.width,thumbCvs.height);
        tCtx.drawImage(pdfCanvas, 0,0,thumbCvs.width,thumbCvs.height); tCtx.drawImage(annotationCanvas, 0,0,thumbCvs.width,thumbCvs.height);
        const thumbnailData = thumbCvs.toDataURL('image/jpeg', 0.6);

        const tx = db.transaction(['files', 'annotations'], 'readwrite');
        tx.objectStore('files').put({ id: fileId, name: fileName, data: originalPdfBytes, thumbnail: thumbnailData });
        tx.objectStore('annotations').put({ fileId, data: annotations });
        await tx.done;
        
        currentFileId = fileId; document.title = fileName;
        // Update URL to include ID
        const url = new URL(window.location); url.searchParams.set('id', fileId); window.history.pushState({}, '', url);
        getEl('loading-overlay').style.display = 'none';
        
        const originalText = saveBtn.innerHTML; saveBtn.innerHTML = "âœ“";
        setTimeout(() => saveBtn.innerHTML = originalText, 1500);
    };

    downloadBtn.onclick = async () => {
        if (!pdfDoc) return;
        getEl('loading-overlay').style.display = 'flex';
        const { PDFDocument, rgb } = PDFLib; 
        const pdfDocToModify = await PDFDocument.load(originalPdfBytes);
        const renderScale = 1.5;
        
        for (const pn in annotations) {
            const idx = parseInt(pn)-1;
            if(idx >= pdfDocToModify.getPageCount()) continue;
            const page = pdfDocToModify.getPages()[idx];
            const { width, height } = page.getSize();
            
            let paths = (annotations[pn]||[]).filter(a => a.type !== 'link').map(a => {
                const d = a.points.map((p,i) => {
                    const x = p.x / renderScale; const y = height - (p.y / renderScale);
                    return (i===0?'M':'L')+`${x.toFixed(2)} ${y.toFixed(2)}`;
                }).join(' ');
                return `<path d="${d}" stroke="${a.color}" stroke-width="${a.width/renderScale}" fill="none" stroke-opacity="${a.type==='highlight'?0.4:1}" stroke-linecap="round" stroke-linejoin="round"/>`;
            }).join('');
            
            if(paths) {
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">${paths}</svg>`;
                page.drawSvg(await pdfDocToModify.embedSvg(svg), {x:0, y:0, width, height});
            }

            const links = (annotations[pn]||[]).filter(a => a.type === 'link');
            for (const l of links) {
                const x = l.x / renderScale; const y = height - ((l.y + l.h) / renderScale);
                const w = l.w / renderScale; const h = l.h / renderScale;
                page.drawRectangle({ x, y, width: w, height: h, color: rgb(0.3, 0.4, 0.9), opacity: 0.2, borderColor: rgb(0.3, 0.4, 0.9), borderWidth: 1 });
                page.drawText('LINK: ' + l.url, { x: x, y: y + h + 2, size: 8, color: rgb(0,0,0) });
            }
        }
        const bytes = await pdfDocToModify.save();
        const blob = new Blob([bytes], {type:'application/pdf'});
        const link = document.createElement('a'); link.href=URL.createObjectURL(blob); link.download=document.title+'.pdf';
        link.click();
        getEl('loading-overlay').style.display = 'none';
    };

    // --- INPUT HANDLING ---
    function getCanvasCoords(e) {
        const rect = annotationCanvas.getBoundingClientRect();
        return { x: (e.clientX - rect.left) * (annotationCanvas.width / rect.width), y: (e.clientY - rect.top) * (annotationCanvas.height / rect.height) };
    }

    mainContent.addEventListener('wheel', e => {
        if(e.ctrlKey) e.preventDefault(); e.preventDefault();
        const rect = mainContent.getBoundingClientRect();
        const newScale = e.deltaY < 0 ? state.transform.scale * 1.1 : state.transform.scale / 1.1;
        const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
        state.transform.offsetX = mouseX - (mouseX - state.transform.offsetX) * (newScale / state.transform.scale);
        state.transform.offsetY = mouseY - (mouseY - state.transform.offsetY) * (newScale / state.transform.scale);
        state.transform.scale = newScale;
        render();
    }, { passive: false });

    mainContent.addEventListener('pointerdown', e => {
        if (!pdfDoc) return;
        pointerCache.set(e.pointerId, { x: e.clientX, y: e.clientY });
        const coords = getCanvasCoords(e);
        
        if (state.activeTool === 'pan' && e.pointerType !== 'pen') {
            const links = (annotations[pageNum] || []).filter(a => a.type === 'link');
            for (const l of links) {
                if (coords.x >= l.x && coords.x <= l.x + l.w && coords.y >= l.y && coords.y <= l.y + l.h) {
                    let url = l.url; if(!url.startsWith('http')) url = 'https://' + url; window.open(url, '_blank'); return;
                }
            }
        }

        if (state.activeTool !== 'pan') {
            state.isDrawing = true;
            if (state.activeTool === 'eraser') { recordHistory(); eraseAtPoint(coords); } 
            else if (state.activeTool === 'line' || state.activeTool === 'link') {
                state.currentPath = { type: state.activeTool, start: coords, points: [coords, coords], color: state.activeTool === 'link' ? state.toolSettings.link.color : state.toolSettings.line.color, width: state.activeTool === 'link' ? 1 : state.toolSettings.line.width };
            } else {
                recordHistory(); state.currentPath = { type: state.activeTool, points: [coords], color: state.toolSettings[state.activeTool].color, width: state.toolSettings[state.activeTool].width };
                if(!annotations[pageNum]) annotations[pageNum] = []; annotations[pageNum].push(state.currentPath);
            }
        }
    });

    mainContent.addEventListener('pointermove', e => {
        if (!pointerCache.has(e.pointerId)) return;
        const last = pointerCache.get(e.pointerId); const coords = getCanvasCoords(e);

        if (state.isDrawing) {
            if (state.activeTool === 'eraser') eraseAtPoint(coords);
            else if (state.activeTool === 'line') { state.currentPath.points[1] = coords; redrawAnnotations(); } 
            else if (state.activeTool === 'link') {
                const start = state.currentPath.start; const w = coords.x - start.x; const h = coords.y - start.y;
                state.currentPath.x = w < 0 ? coords.x : start.x; state.currentPath.y = h < 0 ? coords.y : start.y;
                state.currentPath.w = Math.abs(w); state.currentPath.h = Math.abs(h); redrawAnnotations();
            } else { state.currentPath.points.push(coords); redrawAnnotations(); }
        } else if (pointerCache.size === 1) {
            if (state.activeTool === 'pan' || (e.pointerType !== 'pen' && !state.isDrawing)) {
                pdfContainer.classList.add('panning');
                state.transform.offsetX += e.clientX - last.x; state.transform.offsetY += e.clientY - last.y; render();
            }
        } else if (pointerCache.size === 2) {
            const pointers = Array.from(pointerCache.values());
            const p1 = pointers[0].id === e.pointerId ? {x:e.clientX, y:e.clientY} : pointers[0];
            const p2 = pointers[1].id === e.pointerId ? {x:e.clientX, y:e.clientY} : pointers[1];
            const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
            if (prevPinchDist) {
                const newScale = state.transform.scale * (dist / prevPinchDist);
                const midX = (p1.x + p2.x) / 2 - mainContent.getBoundingClientRect().left;
                const midY = (p1.y + p2.y) / 2 - mainContent.getBoundingClientRect().top;
                state.transform.offsetX = midX - (midX - state.transform.offsetX) * (newScale / state.transform.scale);
                state.transform.offsetY = midY - (midY - state.transform.offsetY) * (newScale / state.transform.scale);
                state.transform.scale = newScale; render();
            }
            prevPinchDist = dist;
        }
        pointerCache.set(e.pointerId, { x: e.clientX, y: e.clientY, id: e.pointerId });
    });

    function handleUp(e) {
        pointerCache.delete(e.pointerId); if(pointerCache.size < 2) prevPinchDist = null;
        if(pointerCache.size === 0) pdfContainer.classList.remove('panning');
        if (state.isDrawing) {
            if (state.activeTool === 'line') { recordHistory(); if(!annotations[pageNum]) annotations[pageNum] = []; annotations[pageNum].push(state.currentPath); } 
            else if (state.activeTool === 'link') {
                if (state.currentPath.w > 5 && state.currentPath.h > 5) {
                    const url = prompt("Enter URL for this link:", "https://");
                    if (url) {
                        recordHistory(); state.currentPath.url = url; delete state.currentPath.points; delete state.currentPath.start;
                        if(!annotations[pageNum]) annotations[pageNum] = []; annotations[pageNum].push(state.currentPath);
                    }
                }
            }
            state.isDrawing = false; state.currentPath = null; redrawAnnotations(); updateUndoRedoButtons();
        }
    }
    mainContent.addEventListener('pointerup', handleUp); mainContent.addEventListener('pointercancel', handleUp); mainContent.addEventListener('pointerleave', handleUp);

    function eraseAtPoint({x,y}) {
        const arr = annotations[pageNum] || [];
        for(let i=arr.length-1; i>=0; i--) {
            const a = arr[i]; let hit = false;
            if (a.type === 'link') { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) hit = true; } 
            else { if (a.points.some(p => Math.hypot(p.x-x, p.y-y) < state.toolSettings.eraser.width)) hit = true; }
            if(hit) { arr.splice(i,1); redrawAnnotations(); break; }
        }
    }
    function recordHistory() { if(!history[pageNum]) history[pageNum]=[]; history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum]||[]))); redoStack[pageNum]=[]; }
    function updateUndoRedoButtons(){ undoBtn.disabled = !history[pageNum]?.length; redoBtn.disabled = !redoStack[pageNum]?.length; }
    undoBtn.onclick = () => { if(history[pageNum]?.length) { redoStack[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum]))); annotations[pageNum]=history[pageNum].pop(); redrawAnnotations(); updateUndoRedoButtons(); }};
    redoBtn.onclick = () => { if(redoStack[pageNum]?.length) { history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum]))); annotations[pageNum]=redoStack[pageNum].pop(); redrawAnnotations(); updateUndoRedoButtons(); }};
    
    function updatePageNavButtons(){ getEl('prev-page-overlay').classList.toggle('disabled', pageNum<=1); getEl('next-page-overlay').classList.toggle('disabled', pageNum>=pdfDoc.numPages); }
    getEl('prev-page-overlay').onclick = () => {if(pageNum>1){pageNum--; render();}};
    getEl('next-page-overlay').onclick = () => {if(pageNum<pdfDoc.numPages){pageNum++; render();}};
    
    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.onclick = () => {
        document.querySelector('.tool-btn.active')?.classList.remove('active'); b.classList.add('active');
        state.activeTool = b.dataset.tool; pdfContainer.setAttribute('data-tool', state.activeTool);
        const t = state.activeTool; const propDiv = getEl('tool-properties'); propDiv.innerHTML = '';
        if(t==='draw'||t==='highlight'||t==='line'){
            propDiv.innerHTML = `<input type="color" id="tc" value="${state.toolSettings[t].color}"><input type="range" id="tw" min="1" max="40" value="${state.toolSettings[t].width}">`;
            getEl('tc').oninput=e=>state.toolSettings[t].color=e.target.value; getEl('tw').oninput=e=>state.toolSettings[t].width=parseInt(e.target.value);
        }
    });
    getEl('reset-view-btn').onclick = fitToScreen;
    
    openDB().then(() => {
        document.querySelector('[data-tool="pan"]').classList.add('active');
        checkURLForFile();
    });
    window.addEventListener('resize', fitToScreen);
    </script>
</body>
</html>
