<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PDF Editor with Dock</title>
    
    <style>
        /* General Setup */
        :root {
            --bg-dark: #202225; --bg-medium: #2f3136; --bg-light: #36393f;
            --text-light: #ffffff; --text-muted: #dcddde; --accent: #5865f2;
            --dock-height: 140px;
        }
        html, body {
            margin: 0; padding: 0; height: 100%; width: 100%;
            overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-light); color: var(--text-light);
            touch-action: none; /* GLOBAL DISABLE SCROLL for App-like feel */
        }

        /* App Layout */
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        
        /* Main Viewport */
        .main-content { 
            flex-grow: 1; 
            position: relative; 
            background: var(--bg-light); 
            overflow: hidden;
            touch-action: none; /* CRITICAL: Allows pinch zoom to work without browser interference */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Toolbar */
        .toolbar {
            flex-shrink: 0; background-color: var(--bg-dark); padding: 8px 16px;
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 12px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 1000;
        }
        .tool-group { display: flex; align-items: center; gap: 6px; border-left: 1px solid var(--bg-light); padding-left: 12px; }
        .tool-btn {
            background: none; border: 2px solid transparent; border-radius: 6px; padding: 6px; 
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            color: var(--text-muted);
        }
        .tool-btn svg { width: 22px; height: 22px; stroke-width: 2; stroke: currentColor; }
        .tool-btn:hover { background-color: var(--bg-medium); color: var(--text-light); }
        .tool-btn.active { background-color: var(--accent); color: white; border-color: var(--accent); }
        .tool-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        #page-num-display { font-size: 14px; font-variant-numeric: tabular-nums; min-width: 80px; text-align: center; }

        /* Tool Properties */
        #tool-properties { display: flex; align-items: center; gap: 10px; }
        input[type="color"] { border: none; width: 28px; height: 28px; padding: 0; background: none; cursor: pointer; }
        input[type="range"] { width: 80px; cursor: pointer; }

        /* PDF Canvas Area */
        #pdf-viewer-container {
            position: absolute; 
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            transform-origin: 0 0; /* Keeps zoom logic simple */
            will-change: transform;
        }
        #pdf-viewer-container[data-tool="pan"] { cursor: grab; }
        #pdf-viewer-container[data-tool="pan"].panning { cursor: grabbing; }
        #pdf-canvas, #annotation-canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        /* Page Navigation Zones */
        .page-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 60px; height: 120px; background: rgba(0,0,0,0.1);
            border-radius: 12px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 500; opacity: 0; transition: opacity 0.2s;
        }
        .main-content:hover .page-nav { opacity: 1; }
        .page-nav:hover { background: rgba(0,0,0,0.4); }
        #prev-page-overlay { left: 10px; }
        #next-page-overlay { right: 10px; }
        .page-nav.disabled { display: none; }

        /* DOCK SYSTEM */
        .dock-container {
            flex-shrink: 0;
            height: var(--dock-height);
            background-color: var(--bg-dark);
            border-top: 1px solid #111;
            display: flex;
            align-items: center;
            overflow-x: auto;
            padding: 0 20px;
            gap: 15px;
            z-index: 2000;
        }
        .dock-container::-webkit-scrollbar { height: 8px; }
        .dock-container::-webkit-scrollbar-thumb { background: var(--bg-medium); border-radius: 4px; }
        
        .dock-item {
            display: flex; flex-direction: column; align-items: center;
            width: 90px; cursor: pointer; position: relative;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        .dock-item:hover { transform: translateY(-5px); }
        .dock-thumb {
            width: 80px; height: 80px; background: white;
            border-radius: 8px; border: 2px solid var(--bg-medium);
            object-fit: contain; background-color: #555;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .dock-item.active .dock-thumb { border-color: var(--accent); box-shadow: 0 0 10px var(--accent); }
        .dock-label {
            font-size: 11px; margin-top: 6px; text-align: center;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%;
            color: var(--text-muted);
        }
        .dock-empty { color: var(--text-muted); width: 100%; text-align: center; font-style: italic; }
        .delete-badge {
            position: absolute; top: -5px; right: 0;
            background: red; color: white; border-radius: 50%; width: 20px; height: 20px;
            display: none; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;
        }
        .dock-item:hover .delete-badge { display: flex; }

        /* Loading */
        #loading-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.6); display: none; 
            justify-content: center; align-items: center; z-index: 9999; 
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #fff; border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <input type="file" id="pdf-upload" accept="application/pdf" style="display: none;">
            <div class="tool-group">
                <!-- Using only the upload button now, files are in the dock -->
                <button class="tool-btn" id="upload-btn" title="Open New PDF"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg></button>
                <button class="tool-btn" id="save-btn" disabled title="Save to Dock"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button>
            </div>
            <span id="page-num-display">No File</span>
            <div class="tool-group">
                <button class="tool-btn" id="undo-btn" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 14H6l-4-4 4-4h15v8zM3 10h18"></path></svg></button>
                <button class="tool-btn" id="redo-btn" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 14h15l4-4-4-4H3v8zM21 10H3"></path></svg></button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" data-tool="pan" title="Pan"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M5 12h14M12 5l7 7-7 7"/></svg></button>
                <button class="tool-btn" data-tool="draw" title="Pen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg></button>
                <button class="tool-btn" data-tool="highlight" title="Marker"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg></button>
                <button class="tool-btn" data-tool="eraser" title="Eraser"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M20.24 7.76l-2.49-2.49a1.5 1.5 0 0 0-2.12 0L3.37 17.51l-1.37 4.86 4.86-1.37L19.12 8.88a1.5 1.5 0 0 0 0-2.12zM15 9l3 3"/></svg></button>
            </div>
            <div id="tool-properties" class="tool-group"></div>
             <div class="tool-group">
                <button class="tool-btn" id="reset-view-btn" title="Fit"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
                <button class="tool-btn" id="download-btn" disabled title="Export"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg></button>
            </div>
        </div>
        
        <div class="main-content" id="main-content">
            <div id="pdf-viewer-container">
                <canvas id="pdf-canvas"></canvas>
                <canvas id="annotation-canvas"></canvas>
            </div>
            <div id="prev-page-overlay" class="page-nav disabled">‹</div>
            <div id="next-page-overlay" class="page-nav disabled">›</div>
        </div>

        <!-- THE DOCK -->
        <div class="dock-container" id="dock-container">
            <div class="dock-empty">Loading saved files...</div>
        </div>
    </div>
    
    <div id="loading-overlay"><div class="spinner"></div></div>

    <script src="https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script>
    // --- SETUP ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js`;
    
    const getEl = id => document.getElementById(id);
    const mainContent = getEl('main-content');
    const uploadInput = getEl('pdf-upload'), uploadBtn = getEl('upload-btn'), saveBtn = getEl('save-btn');
    const pdfCanvas = getEl('pdf-canvas'), annotationCanvas = getEl('annotation-canvas');
    const pdfCtx = pdfCanvas.getContext('2d'), annotationCtx = annotationCanvas.getContext('2d');
    const pageNumDisplay = getEl('page-num-display'), downloadBtn = getEl('download-btn');
    const pdfContainer = getEl('pdf-viewer-container');
    const loadingOverlay = getEl('loading-overlay'), toolPropertiesContainer = getEl('tool-properties');
    const prevPageOverlay = getEl('prev-page-overlay'), nextPageOverlay = getEl('next-page-overlay');
    const undoBtn = getEl('undo-btn'), redoBtn = getEl('redo-btn');
    const dockContainer = getEl('dock-container');

    // --- STATE ---
    let pdfDoc = null, originalPdfBytes = null, pageNum = 1, currentFileId = null;
    let annotations = {};
    let history = {}, redoStack = {};
    let isDbReady = false;
    
    const state = {
        transform: { scale: 1, offsetX: 0, offsetY: 0 },
        isDrawing: false, currentPath: null,
        activeTool: 'pan',
        toolSettings: { draw: { color: '#ff0000', width: 3 }, highlight: { color: '#ffff00', width: 20 }, eraser: { width: 20 } }
    };
    const pointerCache = new Map();
    let prevPinchDist = null;

    // --- DB & DOCK ---
    const DB_NAME = 'PDFEditorDockDB', DB_VERSION = 1;
    let db;

    function openDB() {
        return new Promise((resolve) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onerror = () => { console.warn("DB Blocked"); resolve(null); };
            req.onsuccess = () => { db = req.result; isDbReady = true; resolve(db); };
            req.onupgradeneeded = e => {
                const db = e.target.result;
                // Files store: id, name, data, thumbnail
                if(!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
                // Annotations store: fileId, data
                if(!db.objectStoreNames.contains('annotations')) db.createObjectStore('annotations', { keyPath: 'fileId' });
            };
        });
    }

    async function refreshDock() {
        if (!isDbReady) { dockContainer.innerHTML = '<div class="dock-empty">Local Storage Unavailable</div>'; return; }
        const tx = db.transaction('files', 'readonly');
        const files = await tx.objectStore('files').getAll();
        
        dockContainer.innerHTML = '';
        if (files.length === 0) {
            dockContainer.innerHTML = '<div class="dock-empty">No saved files</div>';
        } else {
            files.forEach(file => {
                const item = document.createElement('div');
                item.className = `dock-item ${file.id === currentFileId ? 'active' : ''}`;
                
                // Use saved thumbnail or a generic placeholder
                const thumbSrc = file.thumbnail || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iI2NjYyIgZD0iTTE0IDJINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlY4bC02LTZ6bTEgN3Y1aDV6Ii8+PC9zdmc+';
                
                item.innerHTML = `
                    <div class="delete-badge" title="Delete">×</div>
                    <img src="${thumbSrc}" class="dock-thumb">
                    <div class="dock-label">${file.name}</div>
                `;
                
                // Click to load
                item.onclick = async (e) => {
                    if (e.target.classList.contains('delete-badge')) {
                        e.stopPropagation();
                        if (confirm(`Delete "${file.name}"?`)) {
                            const txDel = db.transaction(['files', 'annotations'], 'readwrite');
                            txDel.objectStore('files').delete(file.id);
                            txDel.objectStore('annotations').delete(file.id);
                            await txDel.done;
                            if (currentFileId === file.id) window.location.reload();
                            refreshDock();
                        }
                    } else if (file.id !== currentFileId) {
                        const txLoad = db.transaction(['files', 'annotations'], 'readonly');
                        const f = await txLoad.objectStore('files').get(file.id);
                        const a = await txLoad.objectStore('annotations').get(file.id);
                        await loadFile(f.id, f.data, a ? a.data : {}, f.name);
                        refreshDock(); // update active state
                    }
                };
                dockContainer.appendChild(item);
            });
        }
    }

    // --- MAIN LOGIC ---
    function render() {
        if (!pdfDoc) return;
        loadingOverlay.style.display = 'flex';
        
        pdfDoc.getPage(pageNum).then(page => {
            const scaleFactor = 1.5; 
            const viewport = page.getViewport({ scale: scaleFactor });
            
            pdfContainer.style.width = `${viewport.width}px`;
            pdfContainer.style.height = `${viewport.height}px`;
            pdfCanvas.width = viewport.width; pdfCanvas.height = viewport.height;
            annotationCanvas.width = viewport.width; annotationCanvas.height = viewport.height;

            pdfContainer.style.transform = `translate(${state.transform.offsetX}px, ${state.transform.offsetY}px) scale(${state.transform.scale})`;
            
            page.render({ canvasContext: pdfCtx, viewport: viewport }).promise.then(() => {
                redrawAnnotations();
                loadingOverlay.style.display = 'none';
            });
        });
        pageNumDisplay.textContent = `${pageNum} / ${pdfDoc.numPages}`;
        updatePageNavButtons();
    }
    
    function redrawAnnotations() {
        annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        (annotations[pageNum] || []).forEach(anno => {
            annotationCtx.beginPath();
            annotationCtx.moveTo(anno.points[0].x, anno.points[0].y);
            anno.points.forEach(p => annotationCtx.lineTo(p.x, p.y));
            if (anno.type === 'highlight') annotationCtx.globalAlpha = 0.4;
            annotationCtx.strokeStyle = anno.color;
            annotationCtx.lineWidth = anno.width;
            annotationCtx.lineCap = 'round'; annotationCtx.lineJoin = 'round';
            annotationCtx.stroke(); annotationCtx.globalAlpha = 1.0;
        });
    }
    
    function fitToScreen() {
        if (!pdfDoc) return;
        pdfDoc.getPage(pageNum).then(page => {
            const viewport = page.getViewport({ scale: 1.5 });
            const rect = mainContent.getBoundingClientRect();
            const scale = Math.min((rect.width / viewport.width) * 0.9, (rect.height / viewport.height) * 0.9);
            const offsetX = (rect.width - (viewport.width * scale)) / 2;
            const offsetY = (rect.height - (viewport.height * scale)) / 2;
            state.transform = { scale, offsetX, offsetY };
            render();
        });
    }

    async function loadFile(id, fileData, annotationData, name) {
        currentFileId = id;
        originalPdfBytes = fileData;
        annotations = annotationData || {};
        history = {}; redoStack = {};
        pdfDoc = await pdfjsLib.getDocument(new Uint8Array(originalPdfBytes)).promise;
        pageNum = 1;
        document.title = name ? name : "PDF Editor";
        fitToScreen();
        [saveBtn, downloadBtn].forEach(b => b.disabled = false);
        updateUndoRedoButtons();
    }

    // --- EVENT LISTENERS ---
    uploadBtn.onclick = () => uploadInput.click();
    uploadInput.onchange = async e => {
        const file = e.target.files[0]; if (!file) return;
        const buffer = await file.arrayBuffer();
        await loadFile(null, buffer, {}, file.name);
        refreshDock();
    };

    saveBtn.onclick = async () => {
        if (!pdfDoc) return;
        if (!isDbReady) { alert("Database error"); return; }
        
        let fileId = currentFileId;
        let fileName = document.title;

        if (!fileId) {
            fileName = prompt("Name this file:", fileName.replace('*', ''));
            if (!fileName) return;
            fileId = Date.now();
        }

        loadingOverlay.style.display = 'flex';

        // GENERATE THUMBNAIL (Take screenshot of current view)
        // We draw the PDF canvas onto a smaller canvas
        const thumbCvs = document.createElement('canvas');
        const thumbSize = 100; // px
        const ratio = pdfCanvas.width / pdfCanvas.height;
        thumbCvs.width = thumbSize;
        thumbCvs.height = thumbSize / ratio;
        const tCtx = thumbCvs.getContext('2d');
        // White background
        tCtx.fillStyle = '#fff';
        tCtx.fillRect(0, 0, thumbCvs.width, thumbCvs.height);
        tCtx.drawImage(pdfCanvas, 0, 0, thumbCvs.width, thumbCvs.height);
        const thumbnailData = thumbCvs.toDataURL('image/jpeg', 0.7);

        // SAVE TO DB
        const fileData = { id: fileId, name: fileName, data: originalPdfBytes, thumbnail: thumbnailData };
        const annoData = { fileId, data: annotations };
        
        const tx = db.transaction(['files', 'annotations'], 'readwrite');
        tx.objectStore('files').put(fileData);
        tx.objectStore('annotations').put(annoData);
        await tx.done;
        
        currentFileId = fileId;
        document.title = fileName;
        loadingOverlay.style.display = 'none';
        refreshDock();
    };

    // --- POINTER & ZOOM LOGIC ---
    function getCanvasCoords(e) {
        const rect = annotationCanvas.getBoundingClientRect();
        const scaleX = annotationCanvas.width / rect.width;
        const scaleY = annotationCanvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    }

    mainContent.addEventListener('wheel', e => {
        if(e.ctrlKey) e.preventDefault(); // Browser zoom
        e.preventDefault();
        const rect = pdfContainer.getBoundingClientRect();
        const { scale } = state.transform;
        const newScale = e.deltaY < 0 ? scale * 1.1 : scale / 1.1;
        
        // Mouse position relative to wrapper
        const wrapperRect = mainContent.getBoundingClientRect();
        const mouseX = e.clientX - wrapperRect.left;
        const mouseY = e.clientY - wrapperRect.top;
        
        state.transform.offsetX = mouseX - (mouseX - state.transform.offsetX) * (newScale / scale);
        state.transform.offsetY = mouseY - (mouseY - state.transform.offsetY) * (newScale / scale);
        state.transform.scale = newScale;
        render();
    }, { passive: false });

    mainContent.addEventListener('pointerdown', e => {
        if (!pdfDoc) return;
        pointerCache.set(e.pointerId, { x: e.clientX, y: e.clientY });
        
        const isPen = e.pointerType === 'pen';
        
        if (state.activeTool === 'pan' || (e.pointerType === 'touch' && !isPen && state.activeTool !== 'pan')) {
            // Touch always pans unless it's a pen (or if tool is explicitly pan)
            // Wait, if tool is draw, finger should pan? 
            // Standard behavior: One finger pan, Pen draws.
            // Let's enforce: Pen draws if tool != pan. Finger always pans/zooms.
            if (e.pointerType === 'touch' && state.activeTool !== 'pan') return; 
        }

        if (isPen && (state.activeTool === 'draw' || state.activeTool === 'highlight')) {
            state.isDrawing = true;
            recordHistory();
            const { x, y } = getCanvasCoords(e);
            state.currentPath = { type: state.activeTool, points: [{x,y}], color: state.toolSettings[state.activeTool].color, width: state.toolSettings[state.activeTool].width };
            if(!annotations[pageNum]) annotations[pageNum] = [];
            annotations[pageNum].push(state.currentPath);
        } else if (state.activeTool === 'eraser' && isPen) {
            state.isDrawing = true;
            recordHistory();
            eraseAtPoint(getCanvasCoords(e));
        } else if (state.activeTool === 'pan') {
             // Prepare pan
        }
    });

    mainContent.addEventListener('pointermove', e => {
        if (!pointerCache.has(e.pointerId)) return;
        const last = pointerCache.get(e.pointerId);
        
        if (state.isDrawing) {
            const { x, y } = getCanvasCoords(e);
            if (state.activeTool === 'eraser') eraseAtPoint({x,y});
            else { state.currentPath.points.push({x,y}); redrawAnnotations(); }
        } else if (pointerCache.size === 1) {
            // Single finger/mouse pan
            // Only pan if we aren't trying to draw with finger (which we disabled above)
            // or if tool is Pan
            const isPen = e.pointerType === 'pen';
            const shouldPan = state.activeTool === 'pan' || (!isPen && !state.isDrawing);
            
            if (shouldPan) {
                pdfContainer.classList.add('panning');
                state.transform.offsetX += e.clientX - last.x;
                state.transform.offsetY += e.clientY - last.y;
                render();
            }
        } else if (pointerCache.size === 2) {
            // PINCH ZOOM
            const pointers = Array.from(pointerCache.values());
            const p1 = pointers[0], p2 = pointers[1];
            // Current pointers are stored in cache, but we need current EVENT coordinates for the moving one
            // Update the one moving
            if (e.pointerId === p1.id) { p1.x = e.clientX; p1.y = e.clientY; } // Wait, Map stores objects by ref? No.
            // We need to update cache every move at end
            
            // Re-read current positions from event? No, `last` is old pos. 
            // We need valid current positions of both fingers.
            // PointerCache stores the LAST known position.
            // We need to update the specific pointer that moved.
            
            // Find the other pointer
            let otherId = null;
            for(let k of pointerCache.keys()) if(k !== e.pointerId) otherId = k;
            const other = pointerCache.get(otherId);
            
            const dist = Math.hypot(e.clientX - other.x, e.clientY - other.y);
            
            if (prevPinchDist) {
                const oldScale = state.transform.scale;
                const newScale = oldScale * (dist / prevPinchDist);
                const midX = (e.clientX + other.x) / 2;
                const midY = (e.clientY + other.y) / 2;
                
                const rect = mainContent.getBoundingClientRect();
                const midInWrapperX = midX - rect.left;
                const midInWrapperY = midY - rect.top;
                
                state.transform.offsetX = midInWrapperX - (midInWrapperX - state.transform.offsetX) * (newScale / oldScale);
                state.transform.offsetY = midInWrapperY - (midInWrapperY - state.transform.offsetY) * (newScale / oldScale);
                state.transform.scale = newScale;
                render();
            }
            prevPinchDist = dist;
        }
        
        pointerCache.set(e.pointerId, { x: e.clientX, y: e.clientY });
    });

    function handlePointerUp(e) {
        pointerCache.delete(e.pointerId);
        if (pointerCache.size < 2) prevPinchDist = null;
        if (pointerCache.size < 1) pdfContainer.classList.remove('panning');
        state.isDrawing = false; state.currentPath = null;
        updateUndoRedoButtons();
    }
    mainContent.addEventListener('pointerup', handlePointerUp);
    mainContent.addEventListener('pointercancel', handlePointerUp);
    mainContent.addEventListener('pointerleave', handlePointerUp);

    // --- UTILS ---
    function eraseAtPoint({x,y}) {
        const arr = annotations[pageNum] || [];
        for(let i=arr.length-1; i>=0; i--) {
            if(arr[i].points.some(p => Math.hypot(p.x-x, p.y-y) < state.toolSettings.eraser.width)) {
                arr.splice(i,1); redrawAnnotations(); break; 
            }
        }
    }
    function recordHistory() {
        if(!history[pageNum]) history[pageNum]=[];
        history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum]||[])));
        redoStack[pageNum]=[];
    }
    undoBtn.onclick = () => {
        if(history[pageNum]?.length) {
            redoStack[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum])));
            annotations[pageNum] = history[pageNum].pop(); redrawAnnotations(); updateUndoRedoButtons();
        }
    }
    redoBtn.onclick = () => {
        if(redoStack[pageNum]?.length) {
            history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum])));
            annotations[pageNum] = redoStack[pageNum].pop(); redrawAnnotations(); updateUndoRedoButtons();
        }
    }
    function updateUndoRedoButtons(){
        undoBtn.disabled = !history[pageNum]?.length; redoBtn.disabled = !redoStack[pageNum]?.length;
    }
    function updatePageNavButtons(){
        prevPageOverlay.classList.toggle('disabled', pageNum<=1);
        nextPageOverlay.classList.toggle('disabled', pageNum>=pdfDoc.numPages);
    }
    prevPageOverlay.onclick = () => {if(pageNum>1){pageNum--; render();}};
    nextPageOverlay.onclick = () => {if(pageNum<pdfDoc.numPages){pageNum++; render();}};
    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.onclick = () => {
        document.querySelector('.tool-btn.active')?.classList.remove('active');
        b.classList.add('active');
        state.activeTool = b.dataset.tool;
        pdfContainer.dataset.tool = state.activeTool;
        // Tool properties
        const t = state.activeTool;
        toolPropertiesContainer.innerHTML = '';
        if(t==='draw'||t==='highlight'){
            toolPropertiesContainer.innerHTML = `<input type="color" id="tc" value="${state.toolSettings[t].color}"><input type="range" id="tw" min="1" max="40" value="${state.toolSettings[t].width}">`;
            getEl('tc').oninput=e=>state.toolSettings[t].color=e.target.value;
            getEl('tw').oninput=e=>state.toolSettings[t].width=e.target.value;
        }
    });
    document.getElementById('reset-view-btn').onclick = fitToScreen;
    
    // --- INIT ---
    openDB().then(() => {
        setActiveTool('pan');
        // Pre-select pan button
        document.querySelector('[data-tool="pan"]').classList.add('active');
        refreshDock();
    });
    window.addEventListener('resize', fitToScreen);
    
    function setActiveTool(t) { state.activeTool = t; pdfContainer.dataset.tool = t; }

    </script>
</body>
</html>
