<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Local PDF Editor - Fixed Coordinates</title>
    
    <style>
        /* General Setup */
        :root {
            --bg-dark: #2c2f33; --bg-medium: #40444b; --bg-light: #525659;
            --text-light: #ffffff; --text-medium: #b9bbbe; --accent: #7289da;
        }
        html, body {
            margin: 0; padding: 0; height: 100%; width: 100%;
            overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-light); color: var(--text-light);
            touch-action: none; /* Critical for tablet: prevents browser pinch/scroll */
        }

        /* App Layout */
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        .main-content { flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; position: relative; background: var(--bg-light); }

        /* Toolbar */
        .toolbar {
            flex-shrink: 0; background-color: var(--bg-dark); padding: 8px 16px;
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 16px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 1000;
        }
        .tool-group { display: flex; align-items: center; gap: 8px; border-left: 1px solid var(--bg-light); padding-left: 16px; }
        .tool-btn {
            background: none; border: 2px solid transparent; border-radius: 8px; padding: 8px; 
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .tool-btn svg { width: 24px; height: 24px; stroke: var(--text-medium); transition: stroke 0.2s; }
        .tool-btn:hover { background-color: var(--bg-medium); }
        .tool-btn.active { background-color: var(--bg-medium); border-color: var(--accent); }
        .tool-btn.active svg { stroke: var(--accent); }
        .tool-btn:disabled { cursor: not-allowed; opacity: 0.5; }

        /* Tool Properties Bar */
        #tool-properties { display: flex; align-items: center; gap: 12px; }
        input[type="color"] { border: none; background: none; width: 32px; height: 32px; cursor: pointer; border-radius: 50%; overflow: hidden; }
        input[type="range"] { cursor: pointer; }
        #stroke-width-label { min-width: 20px; text-align: center; }

        /* PDF Viewer & Centering */
        #pdf-wrapper { 
            position: relative; 
            width: 100%; 
            height: 100%; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            overflow: hidden; 
        }

        #pdf-viewer-container {
            position: absolute; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            touch-action: none;
            /* CRITICAL FIX 1: Transform origin must be top-left for the math to work */
            transform-origin: 0 0; 
            will-change: transform;
        }

        #pdf-viewer-container[data-tool="pan"] { cursor: grab; }
        #pdf-viewer-container[data-tool="pan"].panning { cursor: grabbing; }
        #pdf-canvas, #annotation-canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        /* On-Screen Page Navigation */
        .page-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 50px; height: 100px; background: rgba(0,0,0,0.2);
            border-radius: 10px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 500; opacity: 0; transition: opacity 0.3s;
        }
        .main-content:hover .page-nav { opacity: 0.7; }
        .page-nav:hover { background: rgba(0,0,0,0.5); opacity: 1; }
        #prev-page-overlay { left: 20px; }
        #next-page-overlay { right: 20px; }
        .page-nav.disabled { display: none; }

        /* Modals (File Manager) & Overlays */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            display: none; justify-content: center; align-items: center; z-index: 9998;
        }
        .modal {
            background: var(--bg-dark); color: var(--text-light); padding: 24px;
            border-radius: 8px; box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto;
        }
        .modal h2 { margin-top: 0; }
        #file-list { list-style: none; padding: 0; }
        #file-list li {
            background: var(--bg-medium); padding: 12px; border-radius: 6px;
            margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;
        }
        #file-list .file-actions button { background-color: var(--bg-light); color: var(--text-light); border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-left: 8px; }
        #file-list .file-actions button:hover { background-color: var(--accent); }
        .modal-close { float: right; cursor: pointer; font-size: 24px; }

        #loading-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 9999; 
        }
        .spinner { width: 50px; height: 50px; border: 5px solid var(--bg-light); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <input type="file" id="pdf-upload" accept="application/pdf" style="display: none;">
            <div class="tool-group">
                <button class="tool-btn" id="files-btn" title="Open Local Files"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg></button>
                <button class="tool-btn" id="upload-btn" title="Import New PDF"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg></button>
                <button class="tool-btn" id="save-btn" disabled title="Save to Browser"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button>
            </div>
            <span id="page-num-display">No PDF Loaded</span>
            <div class="tool-group">
                <button class="tool-btn" id="undo-btn" disabled title="Undo (Ctrl+Z)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 14H6l-4-4 4-4h15v8zM3 10h18"></path></svg></button>
                <button class="tool-btn" id="redo-btn" disabled title="Redo (Ctrl+Y)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 14h15l4-4-4-4H3v8zM21 10H3"></path></svg></button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" data-tool="pan" title="Move View (M)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg></button>
                <button class="tool-btn" data-tool="draw" title="Pen (P)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg></button>
                <button class="tool-btn" data-tool="highlight" title="Highlighter (H)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg></button>
                <button class="tool-btn" data-tool="eraser" title="Eraser (E)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.24 7.76l-2.49-2.49a1.5 1.5 0 0 0-2.12 0L3.37 17.51l-1.37 4.86 4.86-1.37L19.12 8.88a1.5 1.5 0 0 0 0-2.12zM15 9l3 3"/></svg></button>
            </div>
            <div id="tool-properties" class="tool-group"></div>
             <div class="tool-group">
                <button class="tool-btn" id="reset-view-btn" title="Fit to Screen (F)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
                <button class="tool-btn" id="download-btn" disabled title="Download a Copy"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg></button>
            </div>
        </div>
        
        <div class="main-content" id="main-content">
            <div id="pdf-wrapper">
                <div id="pdf-viewer-container">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="annotation-canvas"></canvas>
                </div>
            </div>
            <div id="prev-page-overlay" class="page-nav disabled">...</div>
            <div id="next-page-overlay" class="page-nav disabled">...</div>
        </div>
    </div>

    <!-- File Manager Modal -->
    <div id="files-modal" class="modal-overlay">
        <div class="modal">
            <span class="modal-close" id="files-modal-close">&times;</span>
            <h2>My Local Files</h2>
            <ul id="file-list"><li>No files saved yet.</li></ul>
        </div>
    </div>
    
    <div id="loading-overlay"><div class="spinner"></div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script>
    // --- SETUP & DOM ELEMENTS ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;
    const getEl = id => document.getElementById(id);
    const uploadInput = getEl('pdf-upload'), uploadBtn = getEl('upload-btn'), saveBtn = getEl('save-btn');
    const pdfCanvas = getEl('pdf-canvas'), annotationCanvas = getEl('annotation-canvas');
    const pdfCtx = pdfCanvas.getContext('2d'), annotationCtx = annotationCanvas.getContext('2d');
    const pageNumDisplay = getEl('page-num-display'), downloadBtn = getEl('download-btn');
    const viewerContainer = getEl('main-content'), pdfContainer = getEl('pdf-viewer-container');
    const loadingOverlay = getEl('loading-overlay'), toolPropertiesContainer = getEl('tool-properties');
    const prevPageOverlay = getEl('prev-page-overlay'), nextPageOverlay = getEl('next-page-overlay');
    const filesBtn = getEl('files-btn'), filesModal = getEl('files-modal'), fileList = getEl('file-list');
    const undoBtn = getEl('undo-btn'), redoBtn = getEl('redo-btn');

    // --- STATE MANAGEMENT ---
    let pdfDoc = null, originalPdfBytes = null, pageNum = 1, currentFileId = null;
    let annotations = {};
    let history = {}, redoStack = {};
    
    const state = {
        transform: { scale: 1, offsetX: 0, offsetY: 0 },
        isDrawing: false, currentPath: null,
        activeTool: 'pan',
        toolSettings: { draw: { color: '#ff0000', width: 3 }, highlight: { color: '#ffff00', width: 20 }, eraser: { width: 20 } }
    };
    const pointerCache = new Map();
    let prevPinchDist = null;

    // --- DATABASE (INDEXEDDB) ---
    const DB_NAME = 'PDFEditorDB', DB_VERSION = 1;
    let db;
    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject("Error opening database");
            request.onsuccess = () => { db = request.result; resolve(db); };
            request.onupgradeneeded = e => {
                const db = e.target.result;
                db.createObjectStore('files', { keyPath: 'id' });
                db.createObjectStore('annotations', { keyPath: 'fileId' });
            };
        });
    }

    // --- RENDER & VIEW ---
    function render() {
        if (!pdfDoc) return;
        loadingOverlay.style.display = 'flex';
        
        pdfDoc.getPage(pageNum).then(page => {
            // CRITICAL FIX 3: Higher scale for cleaner text on Xiaomi Tablet
            const scaleFactor = 1.5; 
            const pdfViewport = page.getViewport({ scale: scaleFactor });
            
            // Set CSS dimensions
            pdfContainer.style.width = `${pdfViewport.width}px`;
            pdfContainer.style.height = `${pdfViewport.height}px`;
            
            // Set Canvas Dimensions (Resolution)
            pdfCanvas.width = pdfViewport.width; 
            pdfCanvas.height = pdfViewport.height;
            annotationCanvas.width = pdfViewport.width; 
            annotationCanvas.height = pdfViewport.height;

            // Apply Transform
            pdfContainer.style.transform = `translate(${state.transform.offsetX}px, ${state.transform.offsetY}px) scale(${state.transform.scale})`;
            
            page.render({ canvasContext: pdfCtx, viewport: pdfViewport }).promise.then(() => {
                redrawAnnotations();
                loadingOverlay.style.display = 'none';
            });
        });
        pageNumDisplay.textContent = `Page ${pageNum} / ${pdfDoc.numPages}`;
        updatePageNavButtons();
    }
    
    function redrawAnnotations() {
        annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        (annotations[pageNum] || []).forEach(anno => {
            annotationCtx.beginPath();
            annotationCtx.moveTo(anno.points[0].x, anno.points[0].y);
            anno.points.forEach(p => annotationCtx.lineTo(p.x, p.y));
            
            if (anno.type === 'highlight') annotationCtx.globalAlpha = 0.4;
            annotationCtx.strokeStyle = anno.color;
            annotationCtx.lineWidth = anno.width;
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            annotationCtx.stroke();
            annotationCtx.globalAlpha = 1.0;
        });
    }
    
    function fitToScreen() {
        if (!pdfDoc) return;
        // Reset scale but keep offset to 0
        pdfDoc.getPage(pageNum).then(page => {
            // Match the scale used in render()
            const viewport = page.getViewport({ scale: 1.5 });
            
            // Calculate scale to fit container
            const containerW = viewerContainer.clientWidth;
            const containerH = viewerContainer.clientHeight;
            
            // Scale based on the Canvas size vs Container size
            const scale = Math.min(
                (containerW / viewport.width) * 0.95, 
                (containerH / viewport.height) * 0.95
            );
            
            // Center the PDF in the viewport
            const offsetX = (containerW - (viewport.width * scale)) / 2;
            const offsetY = (containerH - (viewport.height * scale)) / 2;

            state.transform = { scale, offsetX, offsetY };
            render();
        });
    }

    // --- UNDO/REDO LOGIC ---
    function recordHistory() {
        if (!history[pageNum]) history[pageNum] = [];
        history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum] || [])));
        redoStack[pageNum] = [];
        updateUndoRedoButtons();
    }
    
    function undo() {
        if (!history[pageNum] || history[pageNum].length === 0) return;
        if (!redoStack[pageNum]) redoStack[pageNum] = [];
        
        // Push current state to redo
        redoStack[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum] || [])));
        
        // Pop previous state
        const prevState = history[pageNum].pop();
        annotations[pageNum] = prevState;
        
        redrawAnnotations();
        updateUndoRedoButtons();
    }

    function redo() {
        if (!redoStack[pageNum] || redoStack[pageNum].length === 0) return;
        
        // Push current to history
        recordHistoryWithoutClearingRedo(); 
        
        const nextState = redoStack[pageNum].pop();
        annotations[pageNum] = nextState;
        
        redrawAnnotations();
        updateUndoRedoButtons();
    }
    
    function recordHistoryWithoutClearingRedo() {
        if (!history[pageNum]) history[pageNum] = [];
        history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum] || [])));
    }

    function updateUndoRedoButtons() {
        undoBtn.disabled = !history[pageNum] || history[pageNum].length === 0;
        redoBtn.disabled = !redoStack[pageNum] || redoStack[pageNum].length === 0;
    }

    // --- FILE MANAGEMENT ---
    async function loadFile(id, fileData, annotationData) {
        currentFileId = id;
        originalPdfBytes = fileData;
        annotations = annotationData || {};
        history = {}; redoStack = {};
        pdfDoc = await pdfjsLib.getDocument(new Uint8Array(originalPdfBytes)).promise;
        pageNum = 1;
        fitToScreen();
        [saveBtn, downloadBtn].forEach(b => b.disabled = false);
        updateUndoRedoButtons();
    }
    
    uploadBtn.addEventListener('click', () => uploadInput.click());
    uploadInput.addEventListener('change', async e => {
        const file = e.target.files[0]; if (!file) return;
        const tempName = file.name;
        const buffer = await file.arrayBuffer();
        currentFileId = null; 
        document.title = `${tempName}* - PDF Editor`;
        await loadFile(null, buffer, {});
    });

    saveBtn.addEventListener('click', async () => {
        if (!pdfDoc) return;
        loadingOverlay.style.display = 'flex';
        let fileId = currentFileId;
        if (!fileId) {
            const fileName = prompt("Enter a name for this file:", document.title.replace('* - PDF Editor', ''));
            if (!fileName) { loadingOverlay.style.display = 'none'; return; }
            fileId = Date.now();
            const fileData = { id: fileId, name: fileName, data: originalPdfBytes };
            const tx = db.transaction('files', 'readwrite');
            await tx.objectStore('files').put(fileData);
            await tx.done;
            currentFileId = fileId;
            document.title = `${fileName} - PDF Editor`;
        }
        const annotationData = { fileId, data: annotations };
        const txAnno = db.transaction('annotations', 'readwrite');
        await txAnno.objectStore('annotations').put(annotationData);
        await txAnno.done;
        loadingOverlay.style.display = 'none';
        alert("File saved locally!");
    });
    
    filesBtn.addEventListener('click', async () => {
        const tx = db.transaction('files', 'readonly');
        const allFiles = await tx.objectStore('files').getAll();
        fileList.innerHTML = '';
        if (allFiles.length === 0) {
            fileList.innerHTML = '<li>No files saved yet.</li>';
        } else {
            allFiles.forEach(file => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${file.name}</span><div class="file-actions"><button data-id="${file.id}" class="open-file">Open</button><button data-id="${file.id}" class="delete-file">Delete</button></div>`;
                fileList.appendChild(li);
            });
        }
        filesModal.style.display = 'flex';
    });

    fileList.addEventListener('click', async e => {
        const id = parseInt(e.target.dataset.id);
        if (e.target.classList.contains('open-file')) {
            const fileTx = db.transaction('files', 'readonly');
            const file = await fileTx.objectStore('files').get(id);
            const annoTx = db.transaction('annotations', 'readonly');
            const anno = await annoTx.objectStore('annotations').get(id);
            if (file) {
                document.title = `${file.name} - PDF Editor`;
                await loadFile(id, file.data, anno ? anno.data : {});
            }
            filesModal.style.display = 'none';
        }
        if (e.target.classList.contains('delete-file')) {
            if (confirm("Are you sure?")) {
                await db.delete('files', id);
                await db.delete('annotations', id);
                filesBtn.click();
            }
        }
    });

    getEl('files-modal-close').addEventListener('click', () => filesModal.style.display = 'none');
    
    // --- EVENT LISTENERS & TOOLS ---
    document.getElementById('reset-view-btn').addEventListener('click', fitToScreen);
    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => btn.addEventListener('click', () => setActiveTool(btn.dataset.tool)));
    prevPageOverlay.addEventListener('click', () => { if (pageNum > 1) { pageNum--; render(); }});
    nextPageOverlay.addEventListener('click', () => { if (pageNum < pdfDoc.numPages) { pageNum++; render(); }});
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);

    function setActiveTool(tool) {
        document.querySelector('.tool-btn.active')?.classList.remove('active');
        document.querySelector(`.tool-btn[data-tool="${tool}"]`)?.classList.add('active');
        state.activeTool = tool;
        pdfContainer.dataset.tool = tool;
        updateToolPropertiesUI();
    }
    
    function updateToolPropertiesUI() {
        toolPropertiesContainer.innerHTML = ''; const tool = state.activeTool;
        if (tool === 'draw' || tool === 'highlight') {
            const settings = state.toolSettings[tool];
            toolPropertiesContainer.innerHTML = `<div class="prop-item"><input type="color" id="tool-color" value="${settings.color}"></div><div class="prop-item"><input type="range" id="tool-width" min="1" max="50" value="${settings.width}"><span id="stroke-width-label">${settings.width}</span></div>`;
            getEl('tool-color').oninput = e => settings.color = e.target.value;
            getEl('tool-width').oninput = e => { settings.width = e.target.value; getEl('stroke-width-label').textContent = e.target.value; };
        }
    }

    function goToPrevPage() { if (pageNum > 1) { pageNum--; render(); } }
    function goToNextPage() { if (pageNum < pdfDoc.numPages) { pageNum++; render(); } }

    // --- COORDINATE & ZOOM LOGIC ---
    
    // CRITICAL FIX 2: Correct Coordinate Mapping for Scale
    // This calculates the ratio between the visual screen pixels and the internal canvas pixels
    function getCanvasCoords(e) {
        const rect = annotationCanvas.getBoundingClientRect();
        
        // Visual coordinates relative to the canvas element on screen
        const visualX = e.clientX - rect.left;
        const visualY = e.clientY - rect.top;

        // Scaling factor (Internal Pixels / Visual Pixels)
        const scaleX = annotationCanvas.width / rect.width;
        const scaleY = annotationCanvas.height / rect.height;

        return { 
            x: visualX * scaleX, 
            y: visualY * scaleY 
        };
    }

    viewerContainer.addEventListener('wheel', e => {
        e.preventDefault(); 
        const rect = pdfContainer.getBoundingClientRect(); 
        const { scale } = state.transform; 
        const newScale = e.deltaY < 0 ? scale * 1.1 : scale / 1.1;
        
        // Zoom towards mouse position
        // Because transform-origin is 0 0, we must adjust offsetX/Y manually
        const mouseX = e.clientX - rect.left; // Mouse Pos inside element
        const mouseY = e.clientY - rect.top;

        // Formula changes slightly because we are panning the container's TopLeft relative to Wrapper
        // We need the mouse position relative to the Wrapper
        const wrapperRect = viewerContainer.getBoundingClientRect();
        const mouseInWrapperX = e.clientX - wrapperRect.left;
        const mouseInWrapperY = e.clientY - wrapperRect.top;

        // Calculate new offsets to keep mouse point stable
        state.transform.offsetX = mouseInWrapperX - (mouseInWrapperX - state.transform.offsetX) * (newScale / scale);
        state.transform.offsetY = mouseInWrapperY - (mouseInWrapperY - state.transform.offsetY) * (newScale / scale);
        
        state.transform.scale = newScale; 
        render();
    }, { passive: false });

    viewerContainer.addEventListener('pointerdown', e => {
        if (!pdfDoc) return;
        pointerCache.set(e.pointerId, { x: e.clientX, y: e.clientY, lastX: e.clientX, lastY: e.clientY });
        
        const isPen = e.pointerType === 'pen';
        const isEraser = state.activeTool === 'eraser';

        // History recording
        if (e.button === 0 && ((state.activeTool === 'draw' || state.activeTool === 'highlight') && isPen) || (isEraser && !isPen && e.pointerType !== 'touch')) {
            recordHistory();
        }

        if ((state.activeTool === 'draw' || state.activeTool === 'highlight') && isPen) {
            state.isDrawing = true;
            const { x, y } = getCanvasCoords(e);
            const settings = state.toolSettings[state.activeTool];
            state.currentPath = { type: state.activeTool, points: [{ x, y }], color: settings.color, width: settings.width };
            if (!annotations[pageNum]) annotations[pageNum] = [];
            annotations[pageNum].push(state.currentPath);
        } else if (isEraser && e.pointerType !== 'touch') {
            state.isDrawing = true;
            eraseAtPoint(getCanvasCoords(e));
        }
    });
    
    viewerContainer.addEventListener('pointermove', e => {
        if (!pointerCache.has(e.pointerId)) return; 
        const currentPointer = pointerCache.get(e.pointerId);
        
        if (state.isDrawing) {
            const { x, y } = getCanvasCoords(e);
            if (state.activeTool === 'draw' || state.activeTool === 'highlight') { 
                state.currentPath.points.push({ x, y }); 
                redrawAnnotations(); 
            } else if (state.activeTool === 'eraser') { 
                eraseAtPoint({ x, y }); 
            }
        } else if (pointerCache.size === 1 && state.activeTool === 'pan') {
            pdfContainer.classList.add('panning'); 
            const dx = e.clientX - currentPointer.lastX; 
            const dy = e.clientY - currentPointer.lastY;
            state.transform.offsetX += dx; 
            state.transform.offsetY += dy; 
            render();
        } else if (pointerCache.size === 2) {
            // Pinch to Zoom
            const pointers = Array.from(pointerCache.values()); 
            const dist = Math.hypot(pointers[0].x - pointers[1].x, pointers[0].y - pointers[1].y);
            const midX = (pointers[0].x + pointers[1].x) / 2;
            const midY = (pointers[0].y + pointers[1].y) / 2;
            
            if (prevPinchDist) {
                const oldScale = state.transform.scale; 
                const newScale = oldScale * (dist / prevPinchDist);
                
                // Adjust offsets to zoom into center of pinch
                const wrapperRect = viewerContainer.getBoundingClientRect();
                const midInWrapperX = midX - wrapperRect.left;
                const midInWrapperY = midY - wrapperRect.top;

                state.transform.offsetX = midInWrapperX - (midInWrapperX - state.transform.offsetX) * (newScale / oldScale);
                state.transform.offsetY = midInWrapperY - (midInWrapperY - state.transform.offsetY) * (newScale / oldScale);
                
                state.transform.scale = newScale; 
                render();
            }
            prevPinchDist = dist;
        }
        currentPointer.lastX = e.clientX; 
        currentPointer.lastY = e.clientY;
        pointerCache.set(e.pointerId, currentPointer);
    });

    function handlePointerUp(e) {
        pointerCache.delete(e.pointerId); 
        if (pointerCache.size < 2) prevPinchDist = null; 
        if (pointerCache.size < 1) pdfContainer.classList.remove('panning');
        state.isDrawing = false; 
        state.currentPath = null; 
        updateUndoRedoButtons();
    }
    
    viewerContainer.addEventListener('pointerup', handlePointerUp);
    viewerContainer.addEventListener('pointercancel', handlePointerUp);
    
    function eraseAtPoint({ x, y }) {
        let pageAnnotations = annotations[pageNum] || []; let didErase = false;
        // Search backwards to erase top-most items first
        for (let i = pageAnnotations.length - 1; i >= 0; i--) {
            const hit = pageAnnotations[i].points.some(p => Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2)) < state.toolSettings.eraser.width);
            if (hit) { pageAnnotations.splice(i, 1); didErase = true; }
        }
        if (didErase) redrawAnnotations();
    }

    window.addEventListener('keydown', e => {
        if(document.activeElement.tagName === 'INPUT') return;
        if(e.ctrlKey || e.metaKey){ if(e.key.toLowerCase() === 'z') undo(); if(e.key.toLowerCase() === 'y') redo(); return; }
        const key = e.key.toLowerCase();
        if(key === 'arrowleft') goToPrevPage(); 
        if(key === 'arrowright') goToNextPage();
        if(key === 'f') fitToScreen(); 
        if(key === 'm') setActiveTool('pan'); 
        if(key === 'p') setActiveTool('draw');
        if(key === 'h') setActiveTool('highlight'); 
        if(key === 'e') setActiveTool('eraser');
    });

    downloadBtn.addEventListener('click', async () => {
        if (!pdfDoc || !originalPdfBytes) return; 
        loadingOverlay.style.display = 'flex';
        const { PDFDocument } = PDFLib; 
        const pdfDocToModify = await PDFDocument.load(originalPdfBytes);
        
        for (const pageNumKey in annotations) {
            const pageIndex = parseInt(pageNumKey) - 1; 
            if (pageIndex >= pdfDocToModify.getPageCount()) continue;
            
            const page = pdfDocToModify.getPages()[pageIndex]; 
            const { width, height } = page.getSize();
            
            // NOTE: PDF-Lib uses bottom-left (0,0), Canvas uses top-left (0,0)
            // We must flip Y. Since we render at 1.5x scale in UI, we must also scale down coords.
            // However, the annotation coordinates stored are based on the Canvas Size.
            // The Canvas Size was set to Viewport size (1.5x original PDF size).
            // So we need to scale coordinates DOWN by 1.5 to match PDF points.
            
            // We access the scale used during rendering (hardcoded to 1.5 in render())
            const renderScale = 1.5;

            let svgPaths = (annotations[pageNumKey] || []).map(anno => {
                const d = anno.points.map((p, i) => {
                    // Convert Canvas Coord to PDF Coord
                    const pdfX = p.x / renderScale;
                    const pdfY = height - (p.y / renderScale); 
                    return (i === 0 ? 'M' : 'L') + `${pdfX.toFixed(2)} ${pdfY.toFixed(2)}`;
                }).join(' ');
                
                const opacity = anno.type === 'highlight' ? '0.4' : '1.0';
                // Stroke width also needs scaling down
                const strokeWidth = anno.width / renderScale;

                return `<path d="${d}" stroke="${anno.color}" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-opacity="${opacity}" />`;
            }).join('');
            
            if(svgPaths) {
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">${svgPaths}</svg>`;
                page.drawSvg(await pdfDocToModify.embedSvg(svg), { x: 0, y: 0, width, height });
            }
        }
        
        const pdfBytes = await pdfDocToModify.save(); 
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const link = document.createElement('a'); 
        link.href = URL.createObjectURL(blob); 
        link.download = 'annotated_copy.pdf';
        link.click(); 
        loadingOverlay.style.display = 'none';
    });

    // --- INITIALIZATION ---
    async function init() {
        await openDB();
        setActiveTool('pan');
        window.addEventListener('resize', fitToScreen);
    }
    init();
    </script>
</body>
</html>
