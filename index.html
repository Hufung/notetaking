<!-- START OF FILE index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PDF Editor Pro</title>
    
    <style>
        /* --- THEME & RESET --- */
        :root {
            --bg-dark: #202225; --bg-medium: #2f3136; --bg-light: #36393f;
            --text-light: #ffffff; --text-muted: #a0a0a0; --accent: #5865f2;
            --dock-height: 160px;
        }
        html, body {
            margin: 0; padding: 0; height: 100%; width: 100%;
            overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-light); color: var(--text-light);
            touch-action: none; /* PREVENTS BROWSER SCROLL/ZOOM */
        }

        .app-container { display: flex; flex-direction: column; height: 100vh; position: relative; }

        /* --- TOOLBAR --- */
        .toolbar {
            flex-shrink: 0; background-color: var(--bg-dark); padding: 8px 16px;
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 2000;
        }
        .toolbar-section { display: flex; align-items: center; gap: 10px; }
        
        /* Buttons */
        .tool-btn {
            background: var(--bg-medium); border: 1px solid transparent; border-radius: 6px; padding: 8px 12px; 
            cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;
            color: var(--text-light); font-size: 14px; transition: all 0.2s;
        }
        .tool-btn svg { width: 18px; height: 18px; stroke-width: 2; stroke: currentColor; }
        .tool-btn:hover { background-color: #40444b; }
        .tool-btn.active { background-color: var(--accent); border-color: var(--accent); color: white; }
        .tool-btn.file-tab-btn { background-color: #202225; border: 1px solid #444; }
        .tool-btn.file-tab-btn.active { background-color: var(--bg-medium); border-color: var(--text-muted); }
        
        #tool-properties { display: flex; align-items: center; gap: 10px; padding-left: 10px; border-left: 1px solid #444; }
        input[type="color"] { border: none; width: 24px; height: 24px; padding: 0; background: none; cursor: pointer; }
        input[type="range"] { width: 80px; cursor: pointer; }
        
        .zoom-indicator {
            font-size: 13px; font-weight: bold; color: var(--accent); min-width: 45px; text-align: right;
        }

        /* --- MAIN VIEWPORT --- */
        .main-content { 
            flex-grow: 1; position: relative; background: var(--bg-light); 
            overflow: hidden; touch-action: none; 
            display: flex; justify-content: center; align-items: center;
        }

        #pdf-viewer-container {
            position: absolute; 
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            transform-origin: 0 0; 
            will-change: transform;
        }
        #pdf-viewer-container[data-tool="pan"] { cursor: grab; }
        #pdf-viewer-container[data-tool="pan"].panning { cursor: grabbing; }
        #pdf-viewer-container[data-tool="link"] { cursor: crosshair; }
        
        /* Canvas Layers */
        #pdf-canvas, #annotation-canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        /* Page Nav */
        .page-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 50px; height: 100px; background: rgba(0,0,0,0.2);
            border-radius: 8px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 500; opacity: 0; transition: opacity 0.2s; user-select: none;
        }
        .main-content:hover .page-nav { opacity: 1; }
        .page-nav:hover { background: rgba(0,0,0,0.5); }
        #prev-page-overlay { left: 10px; }
        #next-page-overlay { right: 10px; }
        .page-nav.disabled { display: none; }

        /* --- THE DOCKER (FILE BROWSER) --- */
        .dock-wrapper {
            position: absolute; bottom: 0; left: 0; width: 100%;
            height: var(--dock-height);
            background-color: rgba(32, 34, 37, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--accent);
            transform: translateY(100%); /* Hidden by default */
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 3000;
            display: flex; flex-direction: column;
        }
        .dock-wrapper.open { transform: translateY(0); }

        .dock-header {
            padding: 8px 16px; display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.2); font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px;
        }
        .close-dock-btn { background: none; border: none; color: var(--text-light); cursor: pointer; font-size: 18px; }

        .dock-content {
            flex-grow: 1; overflow-x: auto; overflow-y: hidden;
            display: flex; align-items: center; gap: 20px; padding: 0 20px;
        }
        .dock-content::-webkit-scrollbar { height: 6px; }
        .dock-content::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        .file-card {
            display: flex; flex-direction: column; align-items: center; gap: 8px;
            width: 100px; cursor: pointer; position: relative; flex-shrink: 0;
            transition: transform 0.2s;
        }
        .file-card:hover { transform: translateY(-5px); }
        .file-thumb {
            width: 90px; height: 100px; object-fit: contain; background: #fff;
            border-radius: 6px; border: 2px solid #444;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: border-color 0.2s;
        }
        .file-card.active .file-thumb { border-color: var(--accent); box-shadow: 0 0 15px rgba(88, 101, 242, 0.4); }
        .file-name { font-size: 11px; text-align: center; color: var(--text-muted); width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .delete-btn {
            position: absolute; top: -5px; right: 0; width: 20px; height: 20px;
            background: #ed4245; color: white; border-radius: 50%;
            display: none; align-items: center; justify-content: center;
            font-size: 14px; font-weight: bold;
        }
        .file-card:hover .delete-btn { display: flex; }
        
        .dock-empty { width: 100%; text-align: center; color: var(--text-muted); }

        /* Loading */
        #loading-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.6); display: none; 
            justify-content: center; align-items: center; z-index: 9999; 
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #fff; border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- TOOLBAR -->
        <div class="toolbar">
            <div class="toolbar-section">
                <!-- NEW FILE TAB BUTTON -->
                <button class="tool-btn file-tab-btn" id="files-toggle-btn" title="Open File Dock">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
                    Files
                </button>
                <input type="file" id="pdf-upload" accept="application/pdf" style="display: none;">
                <button class="tool-btn" id="upload-btn" title="New PDF"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg> New</button>
                <button class="tool-btn" id="save-btn" disabled title="Save to Dock"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg> Save</button>
                <button class="tool-btn" id="download-btn" disabled title="Export File"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg></button>
            </div>

            <div class="toolbar-section">
                <span id="page-num-display" style="color: var(--text-muted); font-size: 13px;">No File</span>
                <button class="tool-btn" id="undo-btn" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg></button>
                <button class="tool-btn" id="redo-btn" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path></svg></button>
            </div>

            <div class="toolbar-section">
                <button class="tool-btn" data-tool="pan" title="Pan / Click Links"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></button>
                <button class="tool-btn" data-tool="draw" title="Pen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle></svg></button>
                
                <!-- NEW STRAIGHT LINE TOOL -->
                <button class="tool-btn" data-tool="line" title="Straight Line"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="4" y1="20" x2="20" y2="4"></line></svg></button>
                
                <button class="tool-btn" data-tool="highlight" title="Marker"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg></button>
                
                <!-- NEW LINK TOOL -->
                <button class="tool-btn" data-tool="link" title="Insert Link URL"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></button>

                <button class="tool-btn" data-tool="eraser" title="Eraser"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                
                <div id="tool-properties"></div>
                
                <button class="tool-btn" id="reset-view-btn" title="Fit View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path></svg></button>
                
                <!-- NEW ZOOM INDICATOR -->
                <span id="zoom-indicator" class="zoom-indicator">100%</span>
            </div>
        </div>
        
        <!-- VIEWER -->
        <div class="main-content" id="main-content">
            <div id="pdf-viewer-container">
                <canvas id="pdf-canvas"></canvas>
                <canvas id="annotation-canvas"></canvas>
            </div>
            <div id="prev-page-overlay" class="page-nav disabled">â€¹</div>
            <div id="next-page-overlay" class="page-nav disabled">â€º</div>
        </div>

        <!-- DOCKER (FILE BROWSER) -->
        <div class="dock-wrapper" id="dock-wrapper">
            <div class="dock-header">
                <span>Local Library</span>
                <button class="close-dock-btn" id="close-dock">&times;</button>
            </div>
            <div class="dock-content" id="dock-content">
                <div class="dock-empty">Loading local files...</div>
            </div>
        </div>
    </div>
    
    <div id="loading-overlay"><div class="spinner"></div></div>

    <!-- SCRIPTS -->
    <script src="https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script>
    // --- INIT ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js`;
    
    const getEl = id => document.getElementById(id);
    const mainContent = getEl('main-content');
    const pdfCanvas = getEl('pdf-canvas'), annotationCanvas = getEl('annotation-canvas');
    const pdfCtx = pdfCanvas.getContext('2d'), annotationCtx = annotationCanvas.getContext('2d');
    const pdfContainer = getEl('pdf-viewer-container');
    const dockWrapper = getEl('dock-wrapper'), dockContent = getEl('dock-content');
    const zoomIndicator = getEl('zoom-indicator');
    
    // Buttons
    const filesToggleBtn = getEl('files-toggle-btn'), closeDockBtn = getEl('close-dock');
    const uploadBtn = getEl('upload-btn'), uploadInput = getEl('pdf-upload');
    const saveBtn = getEl('save-btn'), downloadBtn = getEl('download-btn');
    const undoBtn = getEl('undo-btn'), redoBtn = getEl('redo-btn');
    
    // State
    let pdfDoc = null, originalPdfBytes = null, pageNum = 1, currentFileId = null;
    let annotations = {};
    let history = {}, redoStack = {};
    let isDbReady = false;
    let db;
    
    const state = {
        transform: { scale: 1, offsetX: 0, offsetY: 0 },
        isDrawing: false, 
        currentPath: null,
        activeTool: 'pan',
        toolSettings: { 
            draw: { color: '#ff0000', width: 3 }, 
            line: { color: '#ff0000', width: 3 }, // New Line settings
            highlight: { color: '#ffff00', width: 20 }, 
            eraser: { width: 20 },
            link: { color: '#5865f2' } // New Link settings
        }
    };
    const pointerCache = new Map();
    let prevPinchDist = null;

    // --- DB Setup ---
    function openDB() {
        return new Promise((resolve) => {
            const req = indexedDB.open('PDFEditorProDB', 1);
            req.onerror = () => { console.warn("DB Blocked"); resolve(null); };
            req.onsuccess = () => { db = req.result; isDbReady = true; resolve(db); };
            req.onupgradeneeded = e => {
                const db = e.target.result;
                if(!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: 'id' });
                if(!db.objectStoreNames.contains('annotations')) db.createObjectStore('annotations', { keyPath: 'fileId' });
            };
        });
    }

    // --- DOCK LOGIC ---
    function toggleDock() {
        dockWrapper.classList.toggle('open');
        filesToggleBtn.classList.toggle('active');
        if (dockWrapper.classList.contains('open')) refreshDock();
    }
    
    filesToggleBtn.onclick = toggleDock;
    closeDockBtn.onclick = toggleDock;

    async function refreshDock() {
        if (!isDbReady) { dockContent.innerHTML = '<div class="dock-empty">Storage unavailable</div>'; return; }
        const tx = db.transaction('files', 'readonly');
        const files = await tx.objectStore('files').getAll();
        
        dockContent.innerHTML = '';
        if (files.length === 0) {
            dockContent.innerHTML = '<div class="dock-empty">No saved files yet.<br>Click "Save" to add current file.</div>';
            return;
        }

        files.forEach(file => {
            const card = document.createElement('div');
            card.className = `file-card ${file.id === currentFileId ? 'active' : ''}`;
            
            // Thumbnail handling
            const thumbSrc = file.thumbnail || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iI2NjYyIgZD0iTTE0IDJINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlY4bC02LTZ6Ii8+PC9zdmc+';
            
            card.innerHTML = `
                <div class="delete-btn" title="Delete">Ã—</div>
                <img src="${thumbSrc}" class="file-thumb">
                <div class="file-name">${file.name}</div>
            `;
            
            card.onclick = async (e) => {
                if (e.target.classList.contains('delete-btn')) {
                    e.stopPropagation();
                    if (confirm(`Delete "${file.name}"?`)) {
                        const txDel = db.transaction(['files', 'annotations'], 'readwrite');
                        txDel.objectStore('files').delete(file.id);
                        txDel.objectStore('annotations').delete(file.id);
                        await txDel.done;
                        if (currentFileId === file.id) window.location.reload();
                        else refreshDock();
                    }
                } else if (file.id !== currentFileId) {
                    // Load File
                    getEl('loading-overlay').style.display = 'flex';
                    const txLoad = db.transaction(['files', 'annotations'], 'readonly');
                    const f = await txLoad.objectStore('files').get(file.id);
                    const a = await txLoad.objectStore('annotations').get(file.id);
                    await loadFile(f.id, f.data, a ? a.data : {}, f.name);
                    toggleDock(); // close dock on selection
                    getEl('loading-overlay').style.display = 'none';
                }
            };
            dockContent.appendChild(card);
        });
    }

    // --- PDF LOGIC ---
    function render() {
        if (!pdfDoc) return;
        
        pdfDoc.getPage(pageNum).then(page => {
            const scaleFactor = 1.5; 
            const viewport = page.getViewport({ scale: scaleFactor });
            
            pdfContainer.style.width = `${viewport.width}px`;
            pdfContainer.style.height = `${viewport.height}px`;
            pdfCanvas.width = viewport.width; pdfCanvas.height = viewport.height;
            annotationCanvas.width = viewport.width; annotationCanvas.height = viewport.height;

            pdfContainer.style.transform = `translate(${state.transform.offsetX}px, ${state.transform.offsetY}px) scale(${state.transform.scale})`;
            
            // 1. Zoom Indicator Update
            zoomIndicator.textContent = Math.round(state.transform.scale * 100) + '%';
            
            page.render({ canvasContext: pdfCtx, viewport: viewport }).promise.then(() => {
                redrawAnnotations();
            });
        });
        getEl('page-num-display').textContent = `Page ${pageNum}`;
        updatePageNavButtons();
    }
    
    function redrawAnnotations() {
        annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        
        const listToDraw = [...(annotations[pageNum] || [])];
        // If we are currently drawing a line or link, add temp path to list
        if (state.isDrawing && state.currentPath && (state.activeTool === 'line' || state.activeTool === 'link')) {
            listToDraw.push(state.currentPath);
        }

        listToDraw.forEach(anno => {
            annotationCtx.save();
            if (anno.type === 'link') {
                // Draw Link Rectangle
                annotationCtx.fillStyle = 'rgba(88, 101, 242, 0.2)';
                annotationCtx.strokeStyle = 'rgba(88, 101, 242, 0.8)';
                annotationCtx.lineWidth = 2;
                annotationCtx.fillRect(anno.x, anno.y, anno.w, anno.h);
                annotationCtx.strokeRect(anno.x, anno.y, anno.w, anno.h);
                
                // Draw Link Icon
                annotationCtx.fillStyle = '#fff';
                annotationCtx.font = '12px sans-serif';
                annotationCtx.fillText("ðŸ”—", anno.x + 4, anno.y + 16);
            } else {
                // Draw Paths (Pen, Highlight, Line)
                annotationCtx.beginPath();
                annotationCtx.moveTo(anno.points[0].x, anno.points[0].y);
                
                if (anno.type === 'line') {
                   // Straight line just connects start to end
                   const end = anno.points[1] || anno.points[0];
                   annotationCtx.lineTo(end.x, end.y);
                } else {
                    // Freehand
                    anno.points.forEach(p => annotationCtx.lineTo(p.x, p.y));
                }

                if (anno.type === 'highlight') annotationCtx.globalAlpha = 0.4;
                annotationCtx.strokeStyle = anno.color;
                annotationCtx.lineWidth = anno.width;
                annotationCtx.lineCap = 'round'; 
                annotationCtx.lineJoin = 'round';
                annotationCtx.stroke(); 
            }
            annotationCtx.restore();
        });
    }
    
    function fitToScreen() {
        if (!pdfDoc) return;
        pdfDoc.getPage(pageNum).then(page => {
            const viewport = page.getViewport({ scale: 1.5 });
            const rect = mainContent.getBoundingClientRect();
            const scale = Math.min((rect.width / viewport.width) * 0.95, (rect.height / viewport.height) * 0.95);
            const offsetX = (rect.width - (viewport.width * scale)) / 2;
            const offsetY = (rect.height - (viewport.height * scale)) / 2;
            state.transform = { scale, offsetX, offsetY };
            render();
        });
    }

    async function loadFile(id, fileData, annotationData, name) {
        currentFileId = id;
        originalPdfBytes = fileData;
        annotations = annotationData || {};
        history = {}; redoStack = {};
        pdfDoc = await pdfjsLib.getDocument(new Uint8Array(originalPdfBytes)).promise;
        pageNum = 1;
        document.title = name || "PDF Editor";
        fitToScreen();
        [saveBtn, downloadBtn, undoBtn, redoBtn].forEach(b => b.disabled = false);
        saveBtn.disabled = false;
        downloadBtn.disabled = false;
        updateUndoRedoButtons();
    }

    // --- ACTIONS ---
    uploadBtn.onclick = () => uploadInput.click();
    uploadInput.onchange = async e => {
        const file = e.target.files[0]; if (!file) return;
        const buffer = await file.arrayBuffer();
        await loadFile(null, buffer, {}, file.name);
    };

    saveBtn.onclick = async () => {
        if (!pdfDoc || !isDbReady) return;
        let fileId = currentFileId;
        let fileName = document.title;
        if (!fileId) {
            fileName = prompt("File Name:", fileName.replace('*', ''));
            if (!fileName) return;
            fileId = Date.now();
        }
        getEl('loading-overlay').style.display = 'flex';
        // 1. Capture Thumbnail
        const thumbCvs = document.createElement('canvas');
        const thumbSize = 120;
        const ratio = pdfCanvas.width / pdfCanvas.height;
        thumbCvs.width = thumbSize;
        thumbCvs.height = thumbSize / ratio;
        const tCtx = thumbCvs.getContext('2d');
        tCtx.fillStyle = '#fff'; tCtx.fillRect(0,0,thumbCvs.width,thumbCvs.height);
        tCtx.drawImage(pdfCanvas, 0,0,thumbCvs.width,thumbCvs.height);
        tCtx.drawImage(annotationCanvas, 0,0,thumbCvs.width,thumbCvs.height);
        const thumbnailData = thumbCvs.toDataURL('image/jpeg', 0.6);

        const fileData = { id: fileId, name: fileName, data: originalPdfBytes, thumbnail: thumbnailData };
        const annoData = { fileId, data: annotations };
        const tx = db.transaction(['files', 'annotations'], 'readwrite');
        tx.objectStore('files').put(fileData);
        tx.objectStore('annotations').put(annoData);
        await tx.done;
        
        currentFileId = fileId;
        document.title = fileName;
        getEl('loading-overlay').style.display = 'none';
        if(dockWrapper.classList.contains('open')) refreshDock();
        else {
            const originalText = filesToggleBtn.innerHTML;
            filesToggleBtn.innerHTML = "âœ“ Saved";
            setTimeout(() => filesToggleBtn.innerHTML = originalText, 1500);
        }
    };

    downloadBtn.onclick = async () => {
        if (!pdfDoc) return;
        getEl('loading-overlay').style.display = 'flex';
        const { PDFDocument, rgb } = PDFLib; 
        const pdfDocToModify = await PDFDocument.load(originalPdfBytes);
        const renderScale = 1.5;
        
        for (const pn in annotations) {
            const idx = parseInt(pn)-1;
            if(idx >= pdfDocToModify.getPageCount()) continue;
            const page = pdfDocToModify.getPages()[idx];
            const { width, height } = page.getSize();
            
            // Draw standard paths (lines/draw/highlight)
            let paths = (annotations[pn]||[]).filter(a => a.type !== 'link').map(a => {
                const d = a.points.map((p,i) => {
                    const x = p.x / renderScale;
                    const y = height - (p.y / renderScale);
                    return (i===0?'M':'L')+`${x.toFixed(2)} ${y.toFixed(2)}`;
                }).join(' ');
                
                // For lines, ensure we close path or just draw line
                return `<path d="${d}" stroke="${a.color}" stroke-width="${a.width/renderScale}" fill="none" stroke-opacity="${a.type==='highlight'?0.4:1}" stroke-linecap="round" stroke-linejoin="round"/>`;
            }).join('');
            
            if(paths) {
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">${paths}</svg>`;
                page.drawSvg(await pdfDocToModify.embedSvg(svg), {x:0, y:0, width, height});
            }

            // Draw Links visually
            const links = (annotations[pn]||[]).filter(a => a.type === 'link');
            for (const l of links) {
                const x = l.x / renderScale;
                // PDF coordinates are bottom-up
                const y = height - ((l.y + l.h) / renderScale);
                const w = l.w / renderScale;
                const h = l.h / renderScale;
                
                // Draw a blue box with the URL text so it's visible in export
                page.drawRectangle({
                    x, y, width: w, height: h,
                    color: rgb(0.3, 0.4, 0.9), opacity: 0.2,
                    borderColor: rgb(0.3, 0.4, 0.9), borderWidth: 1
                });
                page.drawText('LINK: ' + l.url, {
                    x: x, y: y + h + 2,
                    size: 8, color: rgb(0,0,0)
                });
            }
        }
        const bytes = await pdfDocToModify.save();
        const blob = new Blob([bytes], {type:'application/pdf'});
        const link = document.createElement('a'); link.href=URL.createObjectURL(blob); link.download=document.title+'.pdf';
        link.click();
        getEl('loading-overlay').style.display = 'none';
    };

    // --- INPUT HANDLING ---
    function getCanvasCoords(e) {
        const rect = annotationCanvas.getBoundingClientRect();
        const scaleX = annotationCanvas.width / rect.width;
        const scaleY = annotationCanvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    }

    mainContent.addEventListener('wheel', e => {
        if(e.ctrlKey) e.preventDefault();
        e.preventDefault();
        const rect = mainContent.getBoundingClientRect();
        const { scale } = state.transform;
        const newScale = e.deltaY < 0 ? scale * 1.1 : scale / 1.1;
        
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        state.transform.offsetX = mouseX - (mouseX - state.transform.offsetX) * (newScale / scale);
        state.transform.offsetY = mouseY - (mouseY - state.transform.offsetY) * (newScale / scale);
        state.transform.scale = newScale;
        render();
    }, { passive: false });

    mainContent.addEventListener('pointerdown', e => {
        if (!pdfDoc) return;
        pointerCache.set(e.pointerId, { x: e.clientX, y: e.clientY });
        const isPen = e.pointerType === 'pen';
        const coords = getCanvasCoords(e);
        
        // 3. CHECK CLICK ON LINKS (Only in Pan Mode)
        if (state.activeTool === 'pan' && !isPen) {
            const links = (annotations[pageNum] || []).filter(a => a.type === 'link');
            for (const l of links) {
                if (coords.x >= l.x && coords.x <= l.x + l.w && coords.y >= l.y && coords.y <= l.y + l.h) {
                    let url = l.url;
                    if(!url.startsWith('http')) url = 'https://' + url;
                    window.open(url, '_blank');
                    return; // Don't pan if we clicked a link
                }
            }
        }

        if (state.activeTool !== 'pan' && (isPen || state.activeTool !== 'pan')) {
            state.isDrawing = true;
            if (state.activeTool === 'eraser') {
                recordHistory();
                eraseAtPoint(coords);
            } else if (state.activeTool === 'line' || state.activeTool === 'link') {
                // Initialize straight line or link box
                state.currentPath = { 
                    type: state.activeTool, 
                    start: coords, 
                    points: [coords, coords], // index 0 is start, 1 is current end
                    color: state.activeTool === 'link' ? state.toolSettings.link.color : state.toolSettings.line.color, 
                    width: state.activeTool === 'link' ? 1 : state.toolSettings.line.width 
                };
            } else {
                // Freehand
                recordHistory();
                state.currentPath = { type: state.activeTool, points: [coords], color: state.toolSettings[state.activeTool].color, width: state.toolSettings[state.activeTool].width };
                if(!annotations[pageNum]) annotations[pageNum] = [];
                annotations[pageNum].push(state.currentPath);
            }
        }
    });

    mainContent.addEventListener('pointermove', e => {
        if (!pointerCache.has(e.pointerId)) return;
        const last = pointerCache.get(e.pointerId);
        const coords = getCanvasCoords(e);

        if (state.isDrawing) {
            if (state.activeTool === 'eraser') {
                eraseAtPoint(coords);
            } else if (state.activeTool === 'line') {
                // 2. Straight Line Preview
                state.currentPath.points[1] = coords;
                redrawAnnotations();
            } else if (state.activeTool === 'link') {
                // 3. Link Box Preview
                const start = state.currentPath.start;
                const w = coords.x - start.x;
                const h = coords.y - start.y;
                // Normalize rect for rendering
                state.currentPath.x = w < 0 ? coords.x : start.x;
                state.currentPath.y = h < 0 ? coords.y : start.y;
                state.currentPath.w = Math.abs(w);
                state.currentPath.h = Math.abs(h);
                redrawAnnotations();
            } else {
                // Freehand
                state.currentPath.points.push(coords); 
                redrawAnnotations(); 
            }
        } else if (pointerCache.size === 1) {
            // Pan logic
            const isPen = e.pointerType === 'pen';
            if (state.activeTool === 'pan' || (!isPen && !state.isDrawing)) {
                pdfContainer.classList.add('panning');
                state.transform.offsetX += e.clientX - last.x;
                state.transform.offsetY += e.clientY - last.y;
                render();
            }
        } else if (pointerCache.size === 2) {
            // Pinch Zoom
            const pointers = Array.from(pointerCache.values());
            const p1 = pointers[0].id === e.pointerId ? {x:e.clientX, y:e.clientY} : pointers[0];
            const p2 = pointers[1].id === e.pointerId ? {x:e.clientX, y:e.clientY} : pointers[1];
            
            const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
            if (prevPinchDist) {
                const oldScale = state.transform.scale;
                const newScale = oldScale * (dist / prevPinchDist);
                const midX = (p1.x + p2.x) / 2 - mainContent.getBoundingClientRect().left;
                const midY = (p1.y + p2.y) / 2 - mainContent.getBoundingClientRect().top;
                
                state.transform.offsetX = midX - (midX - state.transform.offsetX) * (newScale / oldScale);
                state.transform.offsetY = midY - (midY - state.transform.offsetY) * (newScale / oldScale);
                state.transform.scale = newScale;
                render();
            }
            prevPinchDist = dist;
        }
        pointerCache.set(e.pointerId, { x: e.clientX, y: e.clientY, id: e.pointerId });
    });

    function handleUp(e) {
        pointerCache.delete(e.pointerId);
        if(pointerCache.size < 2) prevPinchDist = null;
        if(pointerCache.size === 0) pdfContainer.classList.remove('panning');
        
        // Finalize drawing for Line or Link
        if (state.isDrawing) {
            if (state.activeTool === 'line') {
                recordHistory();
                if(!annotations[pageNum]) annotations[pageNum] = [];
                annotations[pageNum].push(state.currentPath);
            } else if (state.activeTool === 'link') {
                // 3. Finalize Link creation
                if (state.currentPath.w > 5 && state.currentPath.h > 5) {
                    const url = prompt("Enter URL for this link:", "https://");
                    if (url) {
                        recordHistory();
                        state.currentPath.url = url;
                        // Clean up temp properties
                        delete state.currentPath.points; delete state.currentPath.start;
                        if(!annotations[pageNum]) annotations[pageNum] = [];
                        annotations[pageNum].push(state.currentPath);
                    }
                }
            }
            
            state.isDrawing = false; 
            state.currentPath = null;
            redrawAnnotations();
            updateUndoRedoButtons();
        }
    }
    mainContent.addEventListener('pointerup', handleUp);
    mainContent.addEventListener('pointercancel', handleUp);
    mainContent.addEventListener('pointerleave', handleUp);

    // --- UTILS ---
    function eraseAtPoint({x,y}) {
        const arr = annotations[pageNum] || [];
        for(let i=arr.length-1; i>=0; i--) {
            const a = arr[i];
            let hit = false;
            
            // Check Link Hit
            if (a.type === 'link') {
                if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) hit = true;
            } else {
                // Check Path Hit
                if (a.points.some(p => Math.hypot(p.x-x, p.y-y) < state.toolSettings.eraser.width)) hit = true;
            }

            if(hit) {
                arr.splice(i,1); redrawAnnotations(); break;
            }
        }
    }
    function recordHistory() {
        if(!history[pageNum]) history[pageNum]=[];
        history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum]||[])));
        redoStack[pageNum]=[];
    }
    function updateUndoRedoButtons(){
        undoBtn.disabled = !history[pageNum]?.length; redoBtn.disabled = !redoStack[pageNum]?.length;
    }
    undoBtn.onclick = () => { if(history[pageNum]?.length) { redoStack[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum]))); annotations[pageNum]=history[pageNum].pop(); redrawAnnotations(); updateUndoRedoButtons(); }};
    redoBtn.onclick = () => { if(redoStack[pageNum]?.length) { history[pageNum].push(JSON.parse(JSON.stringify(annotations[pageNum]))); annotations[pageNum]=redoStack[pageNum].pop(); redrawAnnotations(); updateUndoRedoButtons(); }};
    
    function updatePageNavButtons(){
        getEl('prev-page-overlay').classList.toggle('disabled', pageNum<=1);
        getEl('next-page-overlay').classList.toggle('disabled', pageNum>=pdfDoc.numPages);
    }
    getEl('prev-page-overlay').onclick = () => {if(pageNum>1){pageNum--; render();}};
    getEl('next-page-overlay').onclick = () => {if(pageNum<pdfDoc.numPages){pageNum++; render();}};
    
    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.onclick = () => {
        document.querySelector('.tool-btn.active')?.classList.remove('active');
        b.classList.add('active');
        state.activeTool = b.dataset.tool;
        
        // Update PDF cursor based on tool
        pdfContainer.setAttribute('data-tool', state.activeTool);
        
        // Tool properties
        const t = state.activeTool;
        const propDiv = getEl('tool-properties');
        propDiv.innerHTML = '';
        if(t==='draw'||t==='highlight'||t==='line'){
            propDiv.innerHTML = `<input type="color" id="tc" value="${state.toolSettings[t].color}"><input type="range" id="tw" min="1" max="40" value="${state.toolSettings[t].width}">`;
            getEl('tc').oninput=e=>state.toolSettings[t].color=e.target.value;
            getEl('tw').oninput=e=>state.toolSettings[t].width=parseInt(e.target.value);
        }
    });
    getEl('reset-view-btn').onclick = fitToScreen;
    
    // Boot
    openDB().then(() => {
        document.querySelector('[data-tool="pan"]').classList.add('active');
        refreshDock();
    });
    window.addEventListener('resize', fitToScreen);

    </script>
</body>
</html>
